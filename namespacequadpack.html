<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>f2kquadpack: quadpack Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">f2kquadpack
   &#160;<span id="projectnumber">Reference documentation for version 0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Modules&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Module&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">quadpack Module Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This module contains the relevant code for the double precision QUADPACK integration library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:ac1e5b01c1b8779878ebbc064e5f499df"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#ac1e5b01c1b8779878ebbc064e5f499df">xerror</a> (xmess, nmess, nerr, level)</td></tr>
<tr class="memdesc:ac1e5b01c1b8779878ebbc064e5f499df"><td class="mdescLeft">&#160;</td><td class="mdescRight">XERROR replaces the SLATEC XERROR routine.  <a href="#ac1e5b01c1b8779878ebbc064e5f499df">More...</a><br /></td></tr>
<tr class="separator:ac1e5b01c1b8779878ebbc064e5f499df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786a9bfa65b7c81dcdf6cb63535bfaa5"><td class="memItemLeft" align="right" valign="top">real(kind=8) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a786a9bfa65b7c81dcdf6cb63535bfaa5">dqwgtc</a> (x, c, p2, p3, p4, kp)</td></tr>
<tr class="memdesc:a786a9bfa65b7c81dcdf6cb63535bfaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQWGTC defines the weight function used by DQC25C.  <a href="#a786a9bfa65b7c81dcdf6cb63535bfaa5">More...</a><br /></td></tr>
<tr class="separator:a786a9bfa65b7c81dcdf6cb63535bfaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2f9faa3dd3d3923d403fb4e248b765"><td class="memItemLeft" align="right" valign="top">real(kind=8) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a0a2f9faa3dd3d3923d403fb4e248b765">dqwgts</a> (x, a, b, alfa, beta, integr)</td></tr>
<tr class="memdesc:a0a2f9faa3dd3d3923d403fb4e248b765"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQWGTS defines the weight functions used by DQC25S.  <a href="#a0a2f9faa3dd3d3923d403fb4e248b765">More...</a><br /></td></tr>
<tr class="separator:a0a2f9faa3dd3d3923d403fb4e248b765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cee6fc22a1270385fcf68a692d0924"><td class="memItemLeft" align="right" valign="top">real(kind=8) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a67cee6fc22a1270385fcf68a692d0924">dqwgtf</a> (x, omega, p2, p3, p4, integr)</td></tr>
<tr class="memdesc:a67cee6fc22a1270385fcf68a692d0924"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQWGTF defines the weight functions used by DQC25F.  <a href="#a67cee6fc22a1270385fcf68a692d0924">More...</a><br /></td></tr>
<tr class="separator:a67cee6fc22a1270385fcf68a692d0924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa446074b204ed5f8928b1dbd78055c2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#aaa446074b204ed5f8928b1dbd78055c2">dgtsl</a> (n, c, d, e, b, info)</td></tr>
<tr class="memdesc:aaa446074b204ed5f8928b1dbd78055c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">DGTSL solves a general tridiagonal linear system.  <a href="#aaa446074b204ed5f8928b1dbd78055c2">More...</a><br /></td></tr>
<tr class="separator:aaa446074b204ed5f8928b1dbd78055c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413e26c179b8d5f59cb20da7d95244fa"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a413e26c179b8d5f59cb20da7d95244fa">dqage</a> (f, a, b, epsabs, epsrel, key, limit, result, abserr, neval, ier, alist, blist, rlist, elist, iord, last)</td></tr>
<tr class="memdesc:a413e26c179b8d5f59cb20da7d95244fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAGE estimates a definite integral.  <a href="#a413e26c179b8d5f59cb20da7d95244fa">More...</a><br /></td></tr>
<tr class="separator:a413e26c179b8d5f59cb20da7d95244fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be1f7b120414c2269d8d8396b91f36c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a6be1f7b120414c2269d8d8396b91f36c">dqag</a> (f, a, b, epsabs, epsrel, key, result, abserr, neval, ier, limit, lenw, last, iwork, work)</td></tr>
<tr class="memdesc:a6be1f7b120414c2269d8d8396b91f36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAG approximates an integral over a finite interval.  <a href="#a6be1f7b120414c2269d8d8396b91f36c">More...</a><br /></td></tr>
<tr class="separator:a6be1f7b120414c2269d8d8396b91f36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c19e745ac91373b60ea1213baab56ee"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a1c19e745ac91373b60ea1213baab56ee">dqagie</a> (f, bound, inf, epsabs, epsrel, limit, result, abserr, neval, ier, alist, blist, rlist, elist, iord, last)</td></tr>
<tr class="memdesc:a1c19e745ac91373b60ea1213baab56ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAGIE estimates an integral over a semi-infinite or infinite interval.  <a href="#a1c19e745ac91373b60ea1213baab56ee">More...</a><br /></td></tr>
<tr class="separator:a1c19e745ac91373b60ea1213baab56ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6792cfcf8a93be14ed4f24fceb23fc4"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#ac6792cfcf8a93be14ed4f24fceb23fc4">dqagi</a> (f, bound, inf, epsabs, epsrel, result, abserr, neval, ier, limit, lenw, last, iwork, work)</td></tr>
<tr class="memdesc:ac6792cfcf8a93be14ed4f24fceb23fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAGI estimates an integral over a semi-infinite or infinite interval.  <a href="#ac6792cfcf8a93be14ed4f24fceb23fc4">More...</a><br /></td></tr>
<tr class="separator:ac6792cfcf8a93be14ed4f24fceb23fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa2bce54a572e5ceba2f52cb19e6989"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a6aa2bce54a572e5ceba2f52cb19e6989">dqagpe</a> (f, a, b, npts2, points, epsabs, epsrel, limit, result, abserr, neval, ier, alist, blist, rlist, elist, pts, iord, level, ndin, last)</td></tr>
<tr class="memdesc:a6aa2bce54a572e5ceba2f52cb19e6989"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAGPE computes a definite integral.  <a href="#a6aa2bce54a572e5ceba2f52cb19e6989">More...</a><br /></td></tr>
<tr class="separator:a6aa2bce54a572e5ceba2f52cb19e6989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88d627c45a0e8878524b6b5c1654120"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#af88d627c45a0e8878524b6b5c1654120">dqagp</a> (f, a, b, npts2, points, epsabs, epsrel, result, abserr, neval, ier, leniw, lenw, last, iwork, work)</td></tr>
<tr class="memdesc:af88d627c45a0e8878524b6b5c1654120"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAGP computes a definite integral.  <a href="#af88d627c45a0e8878524b6b5c1654120">More...</a><br /></td></tr>
<tr class="separator:af88d627c45a0e8878524b6b5c1654120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dedcead904a064068c119f593b0f10a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a7dedcead904a064068c119f593b0f10a">dqagse</a> (f, a, b, epsabs, epsrel, limit, result, abserr, neval, ier, alist, blist, rlist, elist, iord, last)</td></tr>
<tr class="memdesc:a7dedcead904a064068c119f593b0f10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAGSE estimates the integral of a function.  <a href="#a7dedcead904a064068c119f593b0f10a">More...</a><br /></td></tr>
<tr class="separator:a7dedcead904a064068c119f593b0f10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c66f4c8068a469c8478ad8dbe681ad"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a39c66f4c8068a469c8478ad8dbe681ad">dqags</a> (f, a, b, epsabs, epsrel, result, abserr, neval, ier, limit, lenw, last, iwork, work)</td></tr>
<tr class="memdesc:a39c66f4c8068a469c8478ad8dbe681ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAGS estimates the integral of a function.  <a href="#a39c66f4c8068a469c8478ad8dbe681ad">More...</a><br /></td></tr>
<tr class="separator:a39c66f4c8068a469c8478ad8dbe681ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32241ca02b48584f63ea39b935a21f43"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a32241ca02b48584f63ea39b935a21f43">dqawce</a> (f, a, b, c, epsabs, epsrel, limit, result, abserr, neval, ier, alist, blist, rlist, elist, iord, last)</td></tr>
<tr class="memdesc:a32241ca02b48584f63ea39b935a21f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAWCE computes a Cauchy principal value.  <a href="#a32241ca02b48584f63ea39b935a21f43">More...</a><br /></td></tr>
<tr class="separator:a32241ca02b48584f63ea39b935a21f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8196529041feba74a556d7e8086196f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#ac8196529041feba74a556d7e8086196f">dqawc</a> (f, a, b, c, epsabs, epsrel, result, abserr, neval, ier, limit, lenw, last, iwork, work)</td></tr>
<tr class="memdesc:ac8196529041feba74a556d7e8086196f"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAWC computes a Cauchy principal value.  <a href="#ac8196529041feba74a556d7e8086196f">More...</a><br /></td></tr>
<tr class="separator:ac8196529041feba74a556d7e8086196f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6882b990632eda53f07baf061905bff1"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a6882b990632eda53f07baf061905bff1">dqawfe</a> (f, a, omega, integr, epsabs, limlst, limit, maxp1, result, abserr, neval, ier, rslst, erlst, ierlst, lst, alist, blist, rlist, elist, iord, nnlog, chebmo)</td></tr>
<tr class="memdesc:a6882b990632eda53f07baf061905bff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAWFE computes Fourier integrals.  <a href="#a6882b990632eda53f07baf061905bff1">More...</a><br /></td></tr>
<tr class="separator:a6882b990632eda53f07baf061905bff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad437c3e04b3cf88557425c04e5a25661"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#ad437c3e04b3cf88557425c04e5a25661">dqawf</a> (f, a, omega, integr, epsabs, result, abserr, neval, ier, limlst, lst, leniw, maxp1, lenw, iwork, work)</td></tr>
<tr class="memdesc:ad437c3e04b3cf88557425c04e5a25661"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAWF computes Fourier integrals over the interval [ A, +Infinity ).  <a href="#ad437c3e04b3cf88557425c04e5a25661">More...</a><br /></td></tr>
<tr class="separator:ad437c3e04b3cf88557425c04e5a25661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346b54be67ae642afb55e08eb32dcd6d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a346b54be67ae642afb55e08eb32dcd6d">dqawoe</a> (f, a, b, omega, integr, epsabs, epsrel, limit, icall, maxp1, result, abserr, neval, ier, last, alist, blist, rlist, elist, iord, nnlog, momcom, chebmo)</td></tr>
<tr class="memdesc:a346b54be67ae642afb55e08eb32dcd6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAWOE computes the integrals of oscillatory integrands.  <a href="#a346b54be67ae642afb55e08eb32dcd6d">More...</a><br /></td></tr>
<tr class="separator:a346b54be67ae642afb55e08eb32dcd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95215b7ec043b06831f514b4a0f9bd47"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a95215b7ec043b06831f514b4a0f9bd47">dqawo</a> (f, a, b, omega, integr, epsabs, epsrel, result, abserr, neval, ier, leniw, maxp1, lenw, last, iwork, work)</td></tr>
<tr class="memdesc:a95215b7ec043b06831f514b4a0f9bd47"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAWO computes the integrals of oscillatory integrands.  <a href="#a95215b7ec043b06831f514b4a0f9bd47">More...</a><br /></td></tr>
<tr class="separator:a95215b7ec043b06831f514b4a0f9bd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557929bd4f601dc16fe580f11344b0b2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a557929bd4f601dc16fe580f11344b0b2">dqawse</a> (f, a, b, alfa, beta, integr, epsabs, epsrel, limit, result, abserr, neval, ier, alist, blist, rlist, elist, iord, last)</td></tr>
<tr class="memdesc:a557929bd4f601dc16fe580f11344b0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAWSE estimates integrals with algebraico-logarithmic end singularities.  <a href="#a557929bd4f601dc16fe580f11344b0b2">More...</a><br /></td></tr>
<tr class="separator:a557929bd4f601dc16fe580f11344b0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b769affa04c358c29231bb9befab4be"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a8b769affa04c358c29231bb9befab4be">dqaws</a> (f, a, b, alfa, beta, integr, epsabs, epsrel, result, abserr, neval, ier, limit, lenw, last, iwork, work)</td></tr>
<tr class="memdesc:a8b769affa04c358c29231bb9befab4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQAWS estimates integrals with algebraico-logarithmic endpoint singularities.  <a href="#a8b769affa04c358c29231bb9befab4be">More...</a><br /></td></tr>
<tr class="separator:a8b769affa04c358c29231bb9befab4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407a3ddbb554adffce61182ace3c2a3d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a407a3ddbb554adffce61182ace3c2a3d">dqc25c</a> (f, a, b, c, result, abserr, krul, neval)</td></tr>
<tr class="memdesc:a407a3ddbb554adffce61182ace3c2a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQC25C returns integration rules for Cauchy Principal Value integrals.  <a href="#a407a3ddbb554adffce61182ace3c2a3d">More...</a><br /></td></tr>
<tr class="separator:a407a3ddbb554adffce61182ace3c2a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4247cf39044166b3bf199ea9fee695"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#afd4247cf39044166b3bf199ea9fee695">dqc25f</a> (f, a, b, omega, integr, nrmom, maxp1, ksave, result, abserr, neval, resabs, resasc, momcom, chebmo)</td></tr>
<tr class="memdesc:afd4247cf39044166b3bf199ea9fee695"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQC25F returns integration rules for functions with a COS or SIN factor.  <a href="#afd4247cf39044166b3bf199ea9fee695">More...</a><br /></td></tr>
<tr class="separator:afd4247cf39044166b3bf199ea9fee695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2263d56378a59e2b0d217f6fb6fd62"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a5e2263d56378a59e2b0d217f6fb6fd62">dqc25s</a> (f, a, b, bl, br, alfa, beta, ri, rj, rg, rh, result, abserr, resasc, integr, nev)</td></tr>
<tr class="memdesc:a5e2263d56378a59e2b0d217f6fb6fd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQC25S returns rules for algebraico-logarithmic end point singularities.  <a href="#a5e2263d56378a59e2b0d217f6fb6fd62">More...</a><br /></td></tr>
<tr class="separator:a5e2263d56378a59e2b0d217f6fb6fd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb695f1ae958c0501668ace0493b525"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#affb695f1ae958c0501668ace0493b525">dqcheb</a> (x, fval, cheb12, cheb24)</td></tr>
<tr class="memdesc:affb695f1ae958c0501668ace0493b525"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQCHEB computes the Chebyshev series expansion.  <a href="#affb695f1ae958c0501668ace0493b525">More...</a><br /></td></tr>
<tr class="separator:affb695f1ae958c0501668ace0493b525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c52ea129afde075283ccbd2241b1cc"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#ae1c52ea129afde075283ccbd2241b1cc">dqelg</a> (n, epstab, result, abserr, res3la, nres)</td></tr>
<tr class="memdesc:ae1c52ea129afde075283ccbd2241b1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQELG carries out the Epsilon extrapolation algorithm.  <a href="#ae1c52ea129afde075283ccbd2241b1cc">More...</a><br /></td></tr>
<tr class="separator:ae1c52ea129afde075283ccbd2241b1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a30b889695823050f4f6c588454bbb"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a22a30b889695823050f4f6c588454bbb">dqk15</a> (f, a, b, result, abserr, resabs, resasc)</td></tr>
<tr class="memdesc:a22a30b889695823050f4f6c588454bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQK15 carries out a 15 point Gauss-Kronrod quadrature rule.  <a href="#a22a30b889695823050f4f6c588454bbb">More...</a><br /></td></tr>
<tr class="separator:a22a30b889695823050f4f6c588454bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266d8ac79996877b9c031b36eb31d21a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a266d8ac79996877b9c031b36eb31d21a">dqk15i</a> (f, boun, inf, a, b, result, abserr, resabs, resasc)</td></tr>
<tr class="memdesc:a266d8ac79996877b9c031b36eb31d21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQK15I applies a 15 point Gauss-Kronrod quadrature on an infinite interval.  <a href="#a266d8ac79996877b9c031b36eb31d21a">More...</a><br /></td></tr>
<tr class="separator:a266d8ac79996877b9c031b36eb31d21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7cf1b13718541591e860c6e822b63f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a1d7cf1b13718541591e860c6e822b63f">dqk15w</a> (f, w, p1, p2, p3, p4, kp, a, b, result, abserr, resabs, resasc)</td></tr>
<tr class="memdesc:a1d7cf1b13718541591e860c6e822b63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQK15W applies a 15 point Gauss-Kronrod rule for a weighted integrand.  <a href="#a1d7cf1b13718541591e860c6e822b63f">More...</a><br /></td></tr>
<tr class="separator:a1d7cf1b13718541591e860c6e822b63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4818db594c6e4b4ab9d8572f022a6ffa"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a4818db594c6e4b4ab9d8572f022a6ffa">dqk21</a> (f, a, b, result, abserr, resabs, resasc)</td></tr>
<tr class="memdesc:a4818db594c6e4b4ab9d8572f022a6ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQK21 carries out a 21 point Gauss-Kronrod quadrature rule.  <a href="#a4818db594c6e4b4ab9d8572f022a6ffa">More...</a><br /></td></tr>
<tr class="separator:a4818db594c6e4b4ab9d8572f022a6ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc882b46e46da5e7d2e699dd5a3a18d"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#accc882b46e46da5e7d2e699dd5a3a18d">dqk31</a> (f, a, b, result, abserr, resabs, resasc)</td></tr>
<tr class="memdesc:accc882b46e46da5e7d2e699dd5a3a18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQK31 carries out a 31 point Gauss-Kronrod quadrature rule.  <a href="#accc882b46e46da5e7d2e699dd5a3a18d">More...</a><br /></td></tr>
<tr class="separator:accc882b46e46da5e7d2e699dd5a3a18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987f840704b3b872cd642cf1af36eed2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a987f840704b3b872cd642cf1af36eed2">dqk41</a> (f, a, b, result, abserr, resabs, resasc)</td></tr>
<tr class="memdesc:a987f840704b3b872cd642cf1af36eed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQK41 carries out a 41 point Gauss-Kronrod quadrature rule.  <a href="#a987f840704b3b872cd642cf1af36eed2">More...</a><br /></td></tr>
<tr class="separator:a987f840704b3b872cd642cf1af36eed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b92c134416731a5f3e54e6ee1b7490f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a4b92c134416731a5f3e54e6ee1b7490f">dqk51</a> (f, a, b, result, abserr, resabs, resasc)</td></tr>
<tr class="memdesc:a4b92c134416731a5f3e54e6ee1b7490f"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQK51 carries out a 51 point Gauss-Kronrod quadrature rule.  <a href="#a4b92c134416731a5f3e54e6ee1b7490f">More...</a><br /></td></tr>
<tr class="separator:a4b92c134416731a5f3e54e6ee1b7490f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f18b6b750d715511cf21b601acd9c63"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#a3f18b6b750d715511cf21b601acd9c63">dqk61</a> (f, a, b, result, abserr, resabs, resasc)</td></tr>
<tr class="memdesc:a3f18b6b750d715511cf21b601acd9c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQK61 carries out a 61 point Gauss-Kronrod quadrature rule.  <a href="#a3f18b6b750d715511cf21b601acd9c63">More...</a><br /></td></tr>
<tr class="separator:a3f18b6b750d715511cf21b601acd9c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5d12925721c2511604456c29cf47df"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#aae5d12925721c2511604456c29cf47df">dqmomo</a> (alfa, beta, ri, rj, rg, rh, integr)</td></tr>
<tr class="memdesc:aae5d12925721c2511604456c29cf47df"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQMOMO computes modified Chebyshev moments.  <a href="#aae5d12925721c2511604456c29cf47df">More...</a><br /></td></tr>
<tr class="separator:aae5d12925721c2511604456c29cf47df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80dca0345467a0d301c7e0cdb7b0d9c"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#aa80dca0345467a0d301c7e0cdb7b0d9c">dqng</a> (f, a, b, epsabs, epsrel, result, abserr, neval, ier)</td></tr>
<tr class="memdesc:aa80dca0345467a0d301c7e0cdb7b0d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQNG estimates an integral, using non-adaptive integration.  <a href="#aa80dca0345467a0d301c7e0cdb7b0d9c">More...</a><br /></td></tr>
<tr class="separator:aa80dca0345467a0d301c7e0cdb7b0d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab944c7552a10c8cbc3fcb711d56a4e73"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacequadpack.html#ab944c7552a10c8cbc3fcb711d56a4e73">dqpsrt</a> (limit, last, maxerr, ermax, elist, iord, nrmax)</td></tr>
<tr class="memdesc:ab944c7552a10c8cbc3fcb711d56a4e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">DQPSRT maintains the order of a list of local error estimates.  <a href="#ab944c7552a10c8cbc3fcb711d56a4e73">More...</a><br /></td></tr>
<tr class="separator:ab944c7552a10c8cbc3fcb711d56a4e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This module contains the relevant code for the double precision QUADPACK integration library. </p>
<dl class="section author"><dt>Author</dt><dd>Marco Raveri </dd></dl>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a class="anchor" id="aaa446074b204ed5f8928b1dbd78055c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dgtsl </td>
          <td>(</td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(n)&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(n)&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(n)&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(n)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DGTSL solves a general tridiagonal linear system. </p>
<p>Licensing:</p>
<p>This code is distributed under the GNU LGPL license.</p>
<p>Modified:</p>
<p>17 May 2005</p>
<p>Author:</p>
<p>FORTRAN90 version by John Burkardt.</p>
<p>Reference:</p>
<p>Jack Dongarra, Jim Bunch, Cleve Moler, Pete Stewart, LINPACK User's Guide, SIAM, 1979, ISBN13: 978-0-898711-72-1, LC: QA214.L56.</p>
<p>Parameters:</p>
<p>Input, integer ( kind = 4 ) N, the order of the tridiagonal matrix.</p>
<p>Input/output, real ( kind = 8 ) C(N), contains the subdiagonal of the tridiagonal matrix in entries C(2:N). On output, C is destroyed.</p>
<p>Input/output, real ( kind = 8 ) D(N). On input, the diagonal of the matrix. On output, D is destroyed.</p>
<p>Input/output, real ( kind = 8 ) E(N), contains the superdiagonal of the tridiagonal matrix in entries E(1:N-1). On output E is destroyed.</p>
<p>Input/output, real ( kind = 8 ) B(N). On input, the right hand side. On output, the solution.</p>
<p>Output, integer ( kind = 4 ) INFO, error flag. 0, normal value. K, the K-th element of the diagonal becomes exactly zero. The routine returns if this error condition is detected. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l00182">182</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a6be1f7b120414c2269d8d8396b91f36c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqag </td>
          <td>(</td>
          <td class="paramtype">real ( kind = 8 ), external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>lenw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(lenw)&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAG approximates an integral over a finite interval. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given definite integral i = integral of f over (a,b), hopefully satisfying following claim for accuracy abs(i-result)le.max(epsabs,epsrel*abs(i)).</p>
<p>Parameters: </p><pre class="fragment">f      - real ( kind = 8 )
         function subprogam defining the integrand
         function f(x). the actual name for f needs to be
         declared e x t e r n a l in the driver program.

a      - real ( kind = 8 )
         lower limit of integration

b      - real ( kind = 8 )
         upper limit of integration

epsabs - real ( kind = 8 )
         absolute accoracy requested
epsrel - real ( kind = 8 )
         relative accuracy requested
         if  epsabs.le.0
         and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
         the routine will end with ier = 6.

key    - integer ( kind = 4 )
         key for choice of local integration rule
         a gauss-kronrod pair is used with
           7 - 15 points if key.lt.2,
          10 - 21 points if key = 2,
          15 - 31 points if key = 3,
          20 - 41 points if key = 4,
          25 - 51 points if key = 5,
          30 - 61 points if key.gt.5.
</pre><p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved. ier.gt.0 abnormal termination of the routine the estimates for result and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages ier = 1 maximum number of subdivisions allowed has been achieved. one can allow more subdivisions by increasing the value of limit (and taking the according dimension adjustments into account). however, if this yield no improvement it is advised to analyze the integrand in order to determine the integration difficulaties. if the position of a local difficulty can be determined (i.e.singularity, discontinuity within the interval) one will probably gain from splitting up the interval at this point and calling the integrator on the subranges. if possible, an appropriate special-purpose integrator should be used which is designed for handling the type of difficulty involved. = 2 the occurrence of roundoff error is detected, which prevents the requested tolerance from being achieved. = 3 extremely bad integrand behaviour occurs at some points of the integration interval. = 6 the input is invalid, because (epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28)) or limit.lt.1 or lenw.lt.limit*4. result, abserr, neval, last are set to zero. except when lenw is invalid, iwork(1), work(limit*2+1) and work(limit*3+1) are set to zero, work(1) is set to a and work(limit+1) to b.</p>
<p>dimensioning parameters limit - integer ( kind = 4 ) dimensioning parameter for iwork limit determines the maximum number of subintervals in the partition of the given integration interval (a,b), limit.ge.1. if limit.lt.1, the routine will end with ier = 6.</p>
<p>lenw - integer ( kind = 4 ) dimensioning parameter for work lenw must be at least limit*4. if lenw.lt.limit*4, the routine will end with ier = 6.</p>
<p>last - integer ( kind = 4 ) on return, last equals the number of subintervals produced in the subdivision process, which determines the number of significant elements actually in the work arrays.</p>
<p>work arrays iwork - integer ( kind = 4 ) vector of dimension at least limit, the first k elements of which contain pointers to the error estimates over the subintervals, such that work(limit*3+iwork(1)),... , work(limit*3+iwork(k)) form a decreasing sequence with k = last if last.le.(limit/2+2), and k = limit+1-last otherwise</p>
<p>work - real ( kind = 8 ) vector of dimension at least lenw on return work(1), ..., work(last) contain the left end points of the subintervals in the partition of (a,b), work(limit+1), ..., work(limit+last) contain the right end points, work(limit*2+1), ..., work(limit*2+last) contain the integral approximations over the subintervals, work(limit*3+1), ..., work(limit*3+last) contain the error estimates. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l00795">795</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a413e26c179b8d5f59cb20da7d95244fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqage </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>alist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>blist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>rlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>elist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>iord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAGE estimates a definite integral. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given definite integral i = integral of f over (a,b), hopefully satisfying following claim for accuracy abs(i-reslt).le.max(epsabs,epsrel*abs(i)).</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested epsrel - real ( kind = 8 ) relative accuracy requested if epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), the routine will end with ier = 6.</p>
<p>key - integer ( kind = 4 ) key for choice of local integration rule a gauss-kronrod pair is used with 7 - 15 points if key.lt.2, 10 - 21 points if key = 2, 15 - 31 points if key = 3, 20 - 41 points if key = 4, 25 - 51 points if key = 5, 30 - 61 points if key.gt.5.</p>
<p>limit - integer ( kind = 4 ) gives an upperbound on the number of subintervals in the partition of (a,b), limit.ge.1.</p>
<p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved. ier.gt.0 abnormal termination of the routine the estimates for result and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages ier = 1 maximum number of subdivisions allowed has been achieved. one can allow more subdivisions by increasing the value of limit. however, if this yields no improvement it is rather advised to analyze the integrand in order to determine the integration difficulties. if the position of a local difficulty can be determined(e.g. singularity, discontinuity within the interval) one will probably gain from splitting up the interval at this point and calling the integrator on the subranges. if possible, an appropriate special-purpose integrator should be used which is designed for handling the type of difficulty involved. = 2 the occurrence of roundoff error is detected, which prevents the requested tolerance from being achieved. = 3 extremely bad integrand behaviour occurs at some points of the integration interval. = 6 the input is invalid, because (epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), result, abserr, neval, last, rlist(1) , elist(1) and iord(1) are set to zero. alist(1) and blist(1) are set to a and b respectively.</p>
<p>alist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the left end points of the subintervals in the partition of the given integration range (a,b)</p>
<p>blist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the right end points of the subintervals in the partition of the given integration range (a,b)</p>
<p>rlist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the integral approximations on the subintervals</p>
<p>elist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the moduli of the absolute error estimates on the subintervals</p>
<p>iord - integer ( kind = 4 ) vector of dimension at least limit, the first k elements of which are pointers to the error estimates over the subintervals, such that elist(iord(1)), ..., elist(iord(k)) form a decreasing sequence, with k = last if last.le.(limit/2+2), and k = limit+1-last otherwise</p>
<p>last - integer ( kind = 4 ) number of subintervals actually produced in the subdivision process</p>
<p>Local Parameters:</p>
<p>alist - list of left end points of all subintervals considered up to now blist - list of right end points of all subintervals considered up to now rlist(i) - approximation to the integral over (alist(i),blist(i)) elist(i) - error estimate applying to rlist(i) maxerr - pointer to the interval with largest error estimate errmax - elist(maxerr) area - sum of the integrals over the subintervals errsum - sum of the errors over the subintervals errbnd - requested accuracy max(epsabs,epsrel* abs(result)) *****1 - variable for the left subinterval *****2 - variable for the right subinterval last - index for subdivision</p>
<pre class="fragment"> machine dependent constants

 epmach  is the largest relative spacing.
 uflow  is the smallest positive magnitude.</pre> 
<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l00436">436</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ac6792cfcf8a93be14ed4f24fceb23fc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqagi </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>inf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>lenw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(lenw)&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAGI estimates an integral over a semi-infinite or infinite interval. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given integral i = integral of f over (bound,+infinity) or i = integral of f over (-infinity,bound) or i = integral of f over (-infinity,+infinity) hopefully satisfying following claim for accuracy abs(i-result).le.max(epsabs,epsrel*abs(i)).</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>bound - real ( kind = 8 ) finite bound of integration range (has no meaning if interval is doubly-infinite)</p>
<p>inf - integer ( kind = 4 ) indicating the kind of integration range involved inf = 1 corresponds to (bound,+infinity), inf = -1 to (-infinity,bound), inf = 2 to (-infinity,+infinity).</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested epsrel - real ( kind = 8 ) relative accuracy requested if epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), the routine will end with ier = 6.</p>
<p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved.</p><ul>
<li>ier.gt.0 abnormal termination of the routine. the estimates for result and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages ier = 1 maximum number of subdivisions allowed has been achieved. one can allow more subdivisions by increasing the value of limit (and taking the according dimension adjustments into account). however, if this yields no improvement it is advised to analyze the integrand in order to determine the integration difficulties. if the position of a local difficulty can be determined (e.g. singularity, discontinuity within the interval) one will probably gain from splitting up the interval at this point and calling the integrator on the subranges. if possible, an appropriate special-purpose integrator should be used, which is designed for handling the type of difficulty involved. = 2 the occurrence of roundoff error is detected, which prevents the requested tolerance from being achieved. the error may be under-estimated. = 3 extremely bad integrand behaviour occurs at some points of the integration interval. = 4 the algorithm does not converge. roundoff error is detected in the extrapolation table. it is assumed that the requested tolerance cannot be achieved, and that the returned result is the best which can be obtained. = 5 the integral is probably divergent, or slowly convergent. it must be noted that divergence can occur with any other value of ier. = 6 the input is invalid, because (epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28)) or limit.lt.1 or leniw.lt.limit*4. result, abserr, neval, last are set to zero. exept when limit or leniw is invalid, iwork(1), work(limit*2+1) and work(limit*3+1) are set to zero, work(1) is set to a and work(limit+1) to b.</li>
</ul>
<p>dimensioning parameters limit - integer ( kind = 4 ) dimensioning parameter for iwork limit determines the maximum number of subintervals in the partition of the given integration interval (a,b), limit.ge.1. if limit.lt.1, the routine will end with ier = 6.</p>
<p>lenw - integer ( kind = 4 ) dimensioning parameter for work lenw must be at least limit*4. if lenw.lt.limit*4, the routine will end with ier = 6.</p>
<p>last - integer ( kind = 4 ) on return, last equals the number of subintervals produced in the subdivision process, which determines the number of significant elements actually in the work arrays.</p>
<p>work arrays iwork - integer ( kind = 4 ) vector of dimension at least limit, the first k elements of which contain pointers to the error estimates over the subintervals, such that work(limit*3+iwork(1)),... , work(limit*3+iwork(k)) form a decreasing sequence, with k = last if last.le.(limit/2+2), and k = limit+1-last otherwise</p>
<p>work - real ( kind = 8 ) vector of dimension at least lenw on return work(1), ..., work(last) contain the left end points of the subintervals in the partition of (a,b), work(limit+1), ..., work(limit+last) contain the right end points, work(limit*2+1), ...,work(limit*2+last) contain the integral approximations over the subintervals, work(limit*3+1), ..., work(limit*3) contain the error estimates. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l01467">1467</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a1c19e745ac91373b60ea1213baab56ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqagie </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>inf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>alist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>blist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>rlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>elist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>iord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAGIE estimates an integral over a semi-infinite or infinite interval. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given integral i = integral of f over (bound,+infinity) or i = integral of f over (-infinity,bound) or i = integral of f over (-infinity,+infinity), hopefully satisfying following claim for accuracy abs(i-result).le.max(epsabs,epsrel*abs(i))</p>
<p>Parameters: </p><pre class="fragment">f      - real ( kind = 8 )
         function subprogram defining the integrand
         function f(x). the actual name for f needs to be
         declared e x t e r n a l in the driver program.

bound  - real ( kind = 8 )
         finite bound of integration range
         (has no meaning if interval is doubly-infinite)

inf    - real ( kind = 8 )
         indicating the kind of integration range involved
         inf = 1 corresponds to  (bound,+infinity),
         inf = -1            to  (-infinity,bound),
         inf = 2             to (-infinity,+infinity).

epsabs - real ( kind = 8 )
         absolute accuracy requested
epsrel - real ( kind = 8 )
         relative accuracy requested
         if  epsabs.le.0
         and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
         the routine will end with ier = 6.

limit  - integer ( kind = 4 )
         gives an upper bound on the number of subintervals
         in the partition of (a,b), limit.ge.1
</pre><p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved.</p><ul>
<li>ier.gt.0 abnormal termination of the routine. the estimates for result and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages ier = 1 maximum number of subdivisions allowed has been achieved. one can allow more subdivisions by increasing the value of limit (and taking the according dimension adjustments into account). however,if this yields no improvement it is advised to analyze the integrand in order to determine the integration difficulties. if the position of a local difficulty can be determined (e.g. singularity, discontinuity within the interval) one will probably gain from splitting up the interval at this point and calling the integrator on the subranges. if possible, an appropriate special-purpose integrator should be used, which is designed for handling the type of difficulty involved. = 2 the occurrence of roundoff error is detected, which prevents the requested tolerance from being achieved. the error may be under-estimated. = 3 extremely bad integrand behaviour occurs at some points of the integration interval. = 4 the algorithm does not converge. roundoff error is detected in the extrapolation table. it is assumed that the requested tolerance cannot be achieved, and that the returned result is the best which can be obtained. = 5 the integral is probably divergent, or slowly convergent. it must be noted that divergence can occur with any other value of ier. = 6 the input is invalid, because (epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), result, abserr, neval, last, rlist(1), elist(1) and iord(1) are set to zero. alist(1) and blist(1) are set to 0 and 1 respectively.</li>
</ul>
<p>alist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the left end points of the subintervals in the partition of the transformed integration range (0,1).</p>
<p>blist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the right end points of the subintervals in the partition of the transformed integration range (0,1).</p>
<p>rlist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the integral approximations on the subintervals</p>
<p>elist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the moduli of the absolute error estimates on the subintervals</p>
<p>iord - integer ( kind = 4 ) vector of dimension limit, the first k elements of which are pointers to the error estimates over the subintervals, such that elist(iord(1)), ..., elist(iord(k)) form a decreasing sequence, with k = last if last.le.(limit/2+2), and k = limit+1-last otherwise</p>
<p>last - integer ( kind = 4 ) number of subintervals actually produced in the subdivision process</p>
<p>Local Parameters: </p><pre class="fragment">the dimension of rlist2 is determined by the value of
limexp in routine dqelg.
</pre><p>alist - list of left end points of all subintervals considered up to now blist - list of right end points of all subintervals considered up to now rlist(i) - approximation to the integral over (alist(i),blist(i)) rlist2 - array of dimension at least (limexp+2), containing the part of the epsilon table wich is still needed for further computations elist(i) - error estimate applying to rlist(i) maxerr - pointer to the interval with largest error estimate errmax - elist(maxerr) erlast - error on the interval currently subdivided (before that subdivision has taken place) area - sum of the integrals over the subintervals errsum - sum of the errors over the subintervals errbnd - requested accuracy max(epsabs,epsrel* abs(result)) *****1 - variable for the left subinterval *****2 - variable for the right subinterval last - index for subdivision nres - number of calls to the extrapolation routine numrl2 - number of elements currently in rlist2. if an appropriate approximation to the compounded integral has been obtained, it is put in rlist2(numrl2) after numrl2 has been increased by one. small - length of the smallest interval considered up to now, multiplied by 1.5 erlarg - sum of the errors over the intervals larger than the smallest interval considered up to now extrap - logical variable denoting that the routine is attempting to perform extrapolation. i.e. before subdividing the smallest interval we try to decrease the value of erlarg. noext - logical variable denoting that extrapolation is no longer allowed (true-value)</p>
<p>machine dependent constants</p>
<p>epmach is the largest relative spacing. uflow is the smallest positive magnitude. oflow is the largest positive magnitude. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l01044">1044</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="af88d627c45a0e8878524b6b5c1654120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqagp </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>npts2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(npts2)&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>leniw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>lenw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(leniw)&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(lenw)&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAGP computes a definite integral. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given definite integral i = integral of f over (a,b), hopefully satisfying following claim for accuracy break points of the integration interval, where local difficulties of the integrand may occur (e.g. singularities, discontinuities), are provided by the user.</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration</p>
<p>npts2 - integer ( kind = 4 ) number equal to two more than the number of user-supplied break points within the integration range, npts.ge.2. if npts2.lt.2, the routine will end with ier = 6.</p>
<p>points - real ( kind = 8 ) vector of dimension npts2, the first (npts2-2) elements of which are the user provided break points. if these points do not constitute an ascending sequence there will be an automatic sorting.</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested epsrel - real ( kind = 8 ) relative accuracy requested if epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), the routine will end with ier = 6.</p>
<p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved. ier.gt.0 abnormal termination of the routine. the estimates for integral and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages ier = 1 maximum number of subdivisions allowed has been achieved. one can allow more subdivisions by increasing the value of limit (and taking the according dimension adjustments into account). however, if this yields no improvement it is advised to analyze the integrand in order to determine the integration difficulties. if the position of a local difficulty can be determined (i.e. singularity, discontinuity within the interval), it should be supplied to the routine as an element of the vector points. if necessary an appropriate special-purpose integrator must be used, which is designed for handling the type of difficulty involved. = 2 the occurrence of roundoff error is detected, which prevents the requested tolerance from being achieved. the error may be under-estimated. = 3 extremely bad integrand behaviour occurs at some points of the integration interval. = 4 the algorithm does not converge. roundoff error is detected in the extrapolation table. it is presumed that the requested tolerance cannot be achieved, and that the returned result is the best which can be obtained. = 5 the integral is probably divergent, or slowly convergent. it must be noted that divergence can occur with any other value of ier.gt.0. = 6 the input is invalid because npts2.lt.2 or break points are specified outside the integration range or (epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28)) result, abserr, neval, last are set to zero. exept when leniw or lenw or npts2 is invalid, iwork(1), iwork(limit+1), work(limit*2+1) and work(limit*3+1) are set to zero. work(1) is set to a and work(limit+1) to b (where limit = (leniw-npts2)/2).</p>
<p>dimensioning parameters leniw - integer ( kind = 4 ) dimensioning parameter for iwork leniw determines limit = (leniw-npts2)/2, which is the maximum number of subintervals in the partition of the given integration interval (a,b), leniw.ge.(3*npts2-2). if leniw.lt.(3*npts2-2), the routine will end with ier = 6.</p>
<p>lenw - integer ( kind = 4 ) dimensioning parameter for work lenw must be at least leniw*2-npts2. if lenw.lt.leniw*2-npts2, the routine will end with ier = 6.</p>
<p>last - integer ( kind = 4 ) on return, last equals the number of subintervals produced in the subdivision process, which determines the number of significant elements actually in the work arrays.</p>
<p>work arrays iwork - integer ( kind = 4 ) vector of dimension at least leniw. on return, the first k elements of which contain pointers to the error estimates over the subintervals, such that work(limit*3+iwork(1)),..., work(limit*3+iwork(k)) form a decreasing sequence, with k = last if last.le.(limit/2+2), and k = limit+1-last otherwise iwork(limit+1), ...,iwork(limit+last) contain the subdivision levels of the subintervals, i.e. if (aa,bb) is a subinterval of (p1,p2) where p1 as well as p2 is a user-provided break point or integration limit, then (aa,bb) has level l if abs(bb-aa) = abs(p2-p1)*2**(-l), iwork(limit*2+1), ..., iwork(limit*2+npts2) have no significance for the user, note that limit = (leniw-npts2)/2.</p>
<p>work - real ( kind = 8 ) vector of dimension at least lenw on return work(1), ..., work(last) contain the left end points of the subintervals in the partition of (a,b), work(limit+1), ..., work(limit+last) contain the right end points, work(limit*2+1), ..., work(limit*2+last) contain the integral approximations over the subintervals, work(limit*3+1), ..., work(limit*3+last) contain the corresponding error estimates, work(limit*4+1), ..., work(limit*4+npts2) contain the integration limits and the break points sorted in an ascending sequence. note that limit = (leniw-npts2)/2. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l02241">2241</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a6aa2bce54a572e5ceba2f52cb19e6989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqagpe </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>npts2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(npts2)&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>alist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>blist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>rlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>elist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(npts2)&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>iord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(npts2)&#160;</td>
          <td class="paramname"><em>ndin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAGPE computes a definite integral. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given definite integral i = integral of f over (a,b), hopefully satisfying following claim for accuracy abs(i-result).le. max(epsabs,epsrel*abs(i)). break points of the integration interval, where local difficulties of the integrand may occur(e.g. singularities,discontinuities),provided by user.</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration</p>
<p>npts2 - integer ( kind = 4 ) number equal to two more than the number of user-supplied break points within the integration range, npts2.ge.2. if npts2.lt.2, the routine will end with ier = 6.</p>
<p>points - real ( kind = 8 ) vector of dimension npts2, the first (npts2-2) elements of which are the user provided break points. if these points do not constitute an ascending sequence there will be an automatic sorting.</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested epsrel - real ( kind = 8 ) relative accuracy requested if epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), the routine will end with ier = 6.</p>
<p>limit - integer ( kind = 4 ) gives an upper bound on the number of subintervals in the partition of (a,b), limit.ge.npts2 if limit.lt.npts2, the routine will end with ier = 6.</p>
<p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved. ier.gt.0 abnormal termination of the routine. the estimates for integral and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages ier = 1 maximum number of subdivisions allowed has been achieved. one can allow more subdivisions by increasing the value of limit (and taking the according dimension adjustments into account). however, if this yields no improvement it is advised to analyze the integrand in order to determine the integration difficulties. if the position of a local difficulty can be determined (i.e. singularity, discontinuity within the interval), it should be supplied to the routine as an element of the vector points. if necessary an appropriate special-purpose integrator must be used, which is designed for handling the type of difficulty involved. = 2 the occurrence of roundoff error is detected, which prevents the requested tolerance from being achieved. the error may be under-estimated. = 3 extremely bad integrand behaviour occurs at some points of the integration interval. = 4 the algorithm does not converge. roundoff error is detected in the extrapolation table. it is presumed that the requested tolerance cannot be achieved, and that the returned result is the best which can be obtained. = 5 the integral is probably divergent, or slowly convergent. it must be noted that divergence can occur with any other value of ier.gt.0. = 6 the input is invalid because npts2.lt.2 or break points are specified outside the integration range or (epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28)) or limit.lt.npts2. result, abserr, neval, last, rlist(1), and elist(1) are set to zero. alist(1) and blist(1) are set to a and b respectively.</p>
<p>alist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the left end points of the subintervals in the partition of the given integration range (a,b)</p>
<p>blist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the right end points of the subintervals in the partition of the given integration range (a,b)</p>
<p>rlist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the integral approximations on the subintervals</p>
<p>elist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the moduli of the absolute error estimates on the subintervals</p>
<p>pts - real ( kind = 8 ) vector of dimension at least npts2, containing the integration limits and the break points of the interval in ascending sequence.</p>
<p>level - integer ( kind = 4 ) vector of dimension at least limit, containing the subdivision levels of the subinterval, i.e. if (aa,bb) is a subinterval of (p1,p2) where p1 as well as p2 is a user-provided break point or integration limit, then (aa,bb) has level l if abs(bb-aa) = abs(p2-p1)*2**(-l).</p>
<p>ndin - integer ( kind = 4 ) vector of dimension at least npts2, after first integration over the intervals (pts(i)),pts(i+1), i = 0,1, ..., npts2-2, the error estimates over some of the intervals may have been increased artificially, in order to put their subdivision forward. if this happens for the subinterval numbered k, ndin(k) is put to 1, otherwise ndin(k) = 0.</p>
<p>iord - integer ( kind = 4 ) vector of dimension at least limit, the first k elements of which are pointers to the error estimates over the subintervals, such that elist(iord(1)), ..., elist(iord(k)) form a decreasing sequence, with k = last if last.le.(limit/2+2), and k = limit+1-last otherwise</p>
<p>last - integer ( kind = 4 ) number of subintervals actually produced in the subdivisions process</p>
<p>Local Parameters: </p><pre class="fragment">the dimension of rlist2 is determined by the value of
limexp in routine epsalg (rlist2 should be of dimension
(limexp+2) at least).
</pre><p>alist - list of left end points of all subintervals considered up to now blist - list of right end points of all subintervals considered up to now rlist(i) - approximation to the integral over (alist(i),blist(i)) rlist2 - array of dimension at least limexp+2 containing the part of the epsilon table which is still needed for further computations elist(i) - error estimate applying to rlist(i) maxerr - pointer to the interval with largest error estimate errmax - elist(maxerr) erlast - error on the interval currently subdivided (before that subdivision has taken place) area - sum of the integrals over the subintervals errsum - sum of the errors over the subintervals errbnd - requested accuracy max(epsabs,epsrel* abs(result)) *****1 - variable for the left subinterval *****2 - variable for the right subinterval last - index for subdivision nres - number of calls to the extrapolation routine numrl2 - number of elements in rlist2. if an appropriate approximation to the compounded integral has been obtained, it is put in rlist2(numrl2) after numrl2 has been increased by one. erlarg - sum of the errors over the intervals larger than the smallest interval considered up to now extrap - logical variable denoting that the routine is attempting to perform extrapolation. i.e. before subdividing the smallest interval we try to decrease the value of erlarg. noext - logical variable denoting that extrapolation is no longer allowed (true-value)</p>
<p>machine dependent constants</p>
<p>epmach is the largest relative spacing. uflow is the smallest positive magnitude. oflow is the largest positive magnitude. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l01739">1739</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a39c66f4c8068a469c8478ad8dbe681ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqags </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>lenw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(lenw)&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAGS estimates the integral of a function. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given definite integral i = integral of f over (a,b), hopefully satisfying following claim for accuracy abs(i-result).le.max(epsabs,epsrel*abs(i)).</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested epsrel - real ( kind = 8 ) relative accuracy requested if epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), the routine will end with ier = 6.</p>
<p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved. ier.gt.0 abnormal termination of the routine the estimates for integral and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages ier = 1 maximum number of subdivisions allowed has been achieved. one can allow more sub- divisions by increasing the value of limit (and taking the according dimension adjustments into account. however, if this yields no improvement it is advised to analyze the integrand in order to determine the integration difficulties. if the position of a local difficulty can be determined (e.g. singularity, discontinuity within the interval) one will probably gain from splitting up the interval at this point and calling the integrator on the subranges. if possible, an appropriate special-purpose integrator should be used, which is designed for handling the type of difficulty involved. = 2 the occurrence of roundoff error is detec- ted, which prevents the requested tolerance from being achieved. the error may be under-estimated. = 3 extremely bad integrand behaviour occurs at some points of the integration interval. = 4 the algorithm does not converge. roundoff error is detected in the extrapolation table. it is presumed that the requested tolerance cannot be achieved, and that the returned result is the best which can be obtained. = 5 the integral is probably divergent, or slowly convergent. it must be noted that divergence can occur with any other value of ier. = 6 the input is invalid, because (epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28) or limit.lt.1 or lenw.lt.limit*4. result, abserr, neval, last are set to zero.except when limit or lenw is invalid, iwork(1), work(limit*2+1) and work(limit*3+1) are set to zero, work(1) is set to a and work(limit+1) to b.</p>
<p>dimensioning parameters limit - integer ( kind = 4 ) dimensioning parameter for iwork limit determines the maximum number of subintervals in the partition of the given integration interval (a,b), limit.ge.1. if limit.lt.1, the routine will end with ier = 6.</p>
<p>lenw - integer ( kind = 4 ) dimensioning parameter for work lenw must be at least limit*4. if lenw.lt.limit*4, the routine will end with ier = 6.</p>
<p>last - integer ( kind = 4 ) on return, last equals the number of subintervals produced in the subdivision process, detemines the number of significant elements actually in the work arrays.</p>
<p>work arrays iwork - integer ( kind = 4 ) vector of dimension at least limit, the first k elements of which contain pointers to the error estimates over the subintervals such that work(limit*3+iwork(1)),... , work(limit*3+iwork(k)) form a decreasing sequence, with k = last if last.le.(limit/2+2), and k = limit+1-last otherwise</p>
<p>work - real ( kind = 8 ) vector of dimension at least lenw on return work(1), ..., work(last) contain the left end-points of the subintervals in the partition of (a,b), work(limit+1), ..., work(limit+last) contain the right end-points, work(limit*2+1), ..., work(limit*2+last) contain the integral approximations over the subintervals, work(limit*3+1), ..., work(limit*3+last) contain the error estimates. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l02867">2867</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a7dedcead904a064068c119f593b0f10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqagse </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>alist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>blist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>rlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>elist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>iord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAGSE estimates the integral of a function. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given definite integral i = integral of f over (a,b), hopefully satisfying following claim for accuracy abs(i-result).le.max(epsabs,epsrel*abs(i)).</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested epsrel - real ( kind = 8 ) relative accuracy requested if epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), the routine will end with ier = 6.</p>
<p>limit - integer ( kind = 4 ) gives an upperbound on the number of subintervals in the partition of (a,b)</p>
<p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved. ier.gt.0 abnormal termination of the routine the estimates for integral and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages = 1 maximum number of subdivisions allowed has been achieved. one can allow more sub- divisions by increasing the value of limit (and taking the according dimension adjustments into account). however, if this yields no improvement it is advised to analyze the integrand in order to determine the integration difficulties. if the position of a local difficulty can be determined (e.g. singularity, discontinuity within the interval) one will probably gain from splitting up the interval at this point and calling the integrator on the subranges. if possible, an appropriate special-purpose integrator should be used, which is designed for handling the type of difficulty involved. = 2 the occurrence of roundoff error is detec- ted, which prevents the requested tolerance from being achieved. the error may be under-estimated. = 3 extremely bad integrand behaviour occurs at some points of the integration interval. = 4 the algorithm does not converge. roundoff error is detected in the extrapolation table. it is presumed that the requested tolerance cannot be achieved, and that the returned result is the best which can be obtained. = 5 the integral is probably divergent, or slowly convergent. it must be noted that divergence can occur with any other value of ier. = 6 the input is invalid, because epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28). result, abserr, neval, last, rlist(1), iord(1) and elist(1) are set to zero. alist(1) and blist(1) are set to a and b respectively.</p>
<p>alist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the left end points of the subintervals in the partition of the given integration range (a,b)</p>
<p>blist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the right end points of the subintervals in the partition of the given integration range (a,b)</p>
<p>rlist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the integral approximations on the subintervals</p>
<p>elist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the moduli of the absolute error estimates on the subintervals</p>
<p>iord - integer ( kind = 4 ) vector of dimension at least limit, the first k elements of which are pointers to the error estimates over the subintervals, such that elist(iord(1)), ..., elist(iord(k)) form a decreasing sequence, with k = last if last.le.(limit/2+2), and k = limit+1-last otherwise</p>
<p>last - integer ( kind = 4 ) number of subintervals actually produced in the subdivision process</p>
<p>Local parameters: </p><pre class="fragment">the dimension of rlist2 is determined by the value of
limexp in routine dqelg (rlist2 should be of dimension
(limexp+2) at least).

list of major variables
</pre><p>alist - list of left end points of all subintervals considered up to now blist - list of right end points of all subintervals considered up to now rlist(i) - approximation to the integral over (alist(i),blist(i)) rlist2 - array of dimension at least limexp+2 containing the part of the epsilon table which is still needed for further computations elist(i) - error estimate applying to rlist(i) maxerr - pointer to the interval with largest error estimate errmax - elist(maxerr) erlast - error on the interval currently subdivided (before that subdivision has taken place) area - sum of the integrals over the subintervals errsum - sum of the errors over the subintervals errbnd - requested accuracy max(epsabs,epsrel* abs(result)) *****1 - variable for the left interval *****2 - variable for the right interval last - index for subdivision nres - number of calls to the extrapolation routine numrl2 - number of elements currently in rlist2. if an appropriate approximation to the compounded integral has been obtained it is put in rlist2(numrl2) after numrl2 has been increased by one. small - length of the smallest interval considered up to now, multiplied by 1.5 erlarg - sum of the errors over the intervals larger than the smallest interval considered up to now extrap - logical variable denoting that the routine is attempting to perform extrapolation i.e. before subdividing the smallest interval we try to decrease the value of erlarg. noext - logical variable denoting that extrapolation is no longer allowed (true value)</p>
<p>machine dependent constants</p>
<p>epmach is the largest relative spacing. uflow is the smallest positive magnitude. oflow is the largest positive magnitude. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l02481">2481</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ac8196529041feba74a556d7e8086196f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqawc </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>lenw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(lenw)&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAWC computes a Cauchy principal value. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a cauchy principal value i = integral of f*w over (a,b) (w(x) = 1/((x-c), c.ne.a, c.ne.b), hopefully satisfying following claim for accuracy abs(i-result).le.max(epsabe,epsrel*abs(i)).</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) under limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration</p>
<p>c - parameter in the weight function, c.ne.a, c.ne.b. if c = a or c = b, the routine will end with ier = 6 .</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested epsrel - real ( kind = 8 ) relative accuracy requested if epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), the routine will end with ier = 6.</p>
<p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate or the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved. ier.gt.0 abnormal termination of the routine the estimates for integral and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages ier = 1 maximum number of subdivisions allowed has been achieved. one can allow more sub- divisions by increasing the value of limit (and taking the according dimension adjustments into account). however, if this yields no improvement it is advised to analyze the integrand in order to determine the integration difficulties. if the position of a local difficulty can be determined (e.g. singularity, discontinuity within the interval) one will probably gain from splitting up the interval at this point and calling appropriate integrators on the subranges. = 2 the occurrence of roundoff error is detec- ted, which prevents the requested tolerance from being achieved. = 3 extremely bad integrand behaviour occurs at some points of the integration interval. = 6 the input is invalid, because c = a or c = b or (epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28)) or limit.lt.1 or lenw.lt.limit*4. result, abserr, neval, last are set to zero. exept when lenw or limit is invalid, iwork(1), work(limit*2+1) and work(limit*3+1) are set to zero, work(1) is set to a and work(limit+1) to b.</p>
<p>dimensioning parameters limit - integer ( kind = 4 ) dimensioning parameter for iwork limit determines the maximum number of subintervals in the partition of the given integration interval (a,b), limit.ge.1. if limit.lt.1, the routine will end with ier = 6.</p>
<p>lenw - integer ( kind = 4 ) dimensioning parameter for work lenw must be at least limit*4. if lenw.lt.limit*4, the routine will end with ier = 6.</p>
<p>last - integer ( kind = 4 ) on return, last equals the number of subintervals produced in the subdivision process, which determines the number of significant elements actually in the work arrays.</p>
<p>work arrays iwork - integer ( kind = 4 ) vector of dimension at least limit, the first k elements of which contain pointers to the error estimates over the subintervals, such that work(limit*3+iwork(1)), ... , work(limit*3+iwork(k)) form a decreasing sequence, with k = last if last.le.(limit/2+2), and k = limit+1-last otherwise</p>
<p>work - real ( kind = 8 ) vector of dimension at least lenw on return work(1), ..., work(last) contain the left end points of the subintervals in the partition of (a,b), work(limit+1), ..., work(limit+last) contain the right end points, work(limit*2+1), ..., work(limit*2+last) contain the integral approximations over the subintervals, work(limit*3+1), ..., work(limit*3+last) contain the error estimates. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l03373">3373</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a32241ca02b48584f63ea39b935a21f43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqawce </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>alist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>blist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>rlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>elist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>iord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAWCE computes a Cauchy principal value. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>*** purpose the routine calculates an approximation result to a cauchy principal value i = integral of f*w over (a,b) (w(x) = 1/(x-c), (c.ne.a, c.ne.b), hopefully satisfying following claim for accuracy abs(i-result).le.max(epsabs,epsrel*abs(i))</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration</p>
<p>c - real ( kind = 8 ) parameter in the weight function, c.ne.a, c.ne.b if c = a or c = b, the routine will end with ier = 6.</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested epsrel - real ( kind = 8 ) relative accuracy requested if epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), the routine will end with ier = 6.</p>
<p>limit - integer ( kind = 4 ) gives an upper bound on the number of subintervals in the partition of (a,b), limit.ge.1</p>
<p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved. ier.gt.0 abnormal termination of the routine the estimates for integral and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages ier = 1 maximum number of subdivisions allowed has been achieved. one can allow more sub- divisions by increasing the value of limit. however, if this yields no improvement it is advised to analyze the the integrand, in order to determine the the integration difficulties. if the position of a local difficulty can be determined (e.g. singularity, discontinuity within the interval) one will probably gain from splitting up the interval at this point and calling appropriate integrators on the subranges. = 2 the occurrence of roundoff error is detec- ted, which prevents the requested tolerance from being achieved. = 3 extremely bad integrand behaviour occurs at some interior points of the integration interval. = 6 the input is invalid, because c = a or c = b or (epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28)) or limit.lt.1. result, abserr, neval, rlist(1), elist(1), iord(1) and last are set to zero. alist(1) and blist(1) are set to a and b respectively.</p>
<p>alist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the left end points of the subintervals in the partition of the given integration range (a,b)</p>
<p>blist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the right end points of the subintervals in the partition of the given integration range (a,b)</p>
<p>rlist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the integral approximations on the subintervals</p>
<p>elist - real ( kind = 8 ) vector of dimension limit, the first last elements of which are the moduli of the absolute error estimates on the subintervals</p>
<p>iord - integer ( kind = 4 ) vector of dimension at least limit, the first k elements of which are pointers to the error estimates over the subintervals, so that elist(iord(1)), ..., elist(iord(k)) with k = last if last.le.(limit/2+2), and k = limit+1-last otherwise, form a decreasing sequence</p>
<p>last - integer ( kind = 4 ) number of subintervals actually produced in the subdivision process</p>
<p>Local Parameters:</p>
<p>alist - list of left end points of all subintervals considered up to now blist - list of right end points of all subintervals considered up to now rlist(i) - approximation to the integral over (alist(i),blist(i)) elist(i) - error estimate applying to rlist(i) maxerr - pointer to the interval with largest error estimate errmax - elist(maxerr) area - sum of the integrals over the subintervals errsum - sum of the errors over the subintervals errbnd - requested accuracy max(epsabs,epsrel* abs(result)) *****1 - variable for the left subinterval *****2 - variable for the right subinterval last - index for subdivision</p>
<pre class="fragment">  machine dependent constants

 epmach is the largest relative spacing.
 uflow is the smallest positive magnitude.</pre> 
<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l03062">3062</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ad437c3e04b3cf88557425c04e5a25661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqawf </td>
          <td>(</td>
          <td class="paramtype">real ( kind = 8 ), external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>integr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limlst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>leniw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>maxp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>lenw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(leniw)&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(lenw)&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAWF computes Fourier integrals over the interval [ A, +Infinity ). </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given fourier integral i=integral of f(x)*w(x) over (a,infinity) where w(x) = cos(omega*x) or w(x) = sin(omega*x). hopefully satisfying following claim for accuracy abs(i-result).le.epsabs.</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>omega - real ( kind = 8 ) parameter in the integrand weight function</p>
<p>integr - integer ( kind = 4 ) indicates which of the weight functions is used integr = 1 w(x) = cos(omega*x) integr = 2 w(x) = sin(omega*x) if integr.ne.1.and.integr.ne.2, the routine will end with ier = 6.</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested, epsabs.gt.0. if epsabs.le.0, the routine will end with ier = 6.</p>
<p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved. ier.gt.0 abnormal termination of the routine. the estimates for integral and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages if omega.ne.0 ier = 1 maximum number of cycles allowed has been achieved, i.e. of subintervals (a+(k-1)c,a+kc) where c = (2*int(abs(omega))+1)*pi/abs(omega), for k = 1, 2, ..., lst. one can allow more cycles by increasing the value of limlst (and taking the according dimension adjustments into account). examine the array iwork which contains the error flags on the cycles, in order to look for eventual local integration difficulties. if the position of a local difficulty can be determined (e.g. singularity, discontinuity within the interval) one will probably gain from splitting up the interval at this point and calling appropriate integrators on the subranges. = 4 the extrapolation table constructed for convergence accelaration of the series formed by the integral contributions over the cycles, does not converge to within the requested accuracy. as in the case of ier = 1, it is advised to examine the array iwork which contains the error flags on the cycles. = 6 the input is invalid because (integr.ne.1 and integr.ne.2) or epsabs.le.0 or limlst.lt.1 or leniw.lt.(limlst+2) or maxp1.lt.1 or lenw.lt.(leniw*2+maxp1*25). result, abserr, neval, lst are set to zero. = 7 bad integrand behaviour occurs within one or more of the cycles. location and type of the difficulty involved can be determined from the first lst elements of vector iwork. here lst is the number of cycles actually needed (see below). iwork(k) = 1 the maximum number of subdivisions (=(leniw-limlst) /2) has been achieved on the k th cycle. = 2 occurrence of roundoff error is detected and prevents the tolerance imposed on the k th cycle, from being achieved on this cycle. = 3 extremely bad integrand behaviour occurs at some points of the k th cycle. = 4 the integration procedure over the k th cycle does not converge (to within the required accuracy) due to roundoff in the extrapolation procedure invoked on this cycle. it is assumed that the result on this interval is the best which can be obtained. = 5 the integral over the k th cycle is probably divergent or slowly convergent. it must be noted that divergence can occur with any other value of iwork(k). if omega = 0 and integr = 1, the integral is calculated by means of dqagie, and ier = iwork(1) (with meaning as described for iwork(k),k = 1).</p>
<p>dimensioning parameters limlst - integer ( kind = 4 ) limlst gives an upper bound on the number of cycles, limlst.ge.3. if limlst.lt.3, the routine will end with ier = 6.</p>
<p>lst - integer ( kind = 4 ) on return, lst indicates the number of cycles actually needed for the integration. if omega = 0, then lst is set to 1.</p>
<p>leniw - integer ( kind = 4 ) dimensioning parameter for iwork. on entry, (leniw-limlst)/2 equals the maximum number of subintervals allowed in the partition of each cycle, leniw.ge.(limlst+2). if leniw.lt.(limlst+2), the routine will end with ier = 6.</p>
<p>maxp1 - integer ( kind = 4 ) maxp1 gives an upper bound on the number of chebyshev moments which can be stored, i.e. for the intervals of lengths abs(b-a)*2**(-l), l = 0,1, ..., maxp1-2, maxp1.ge.1. if maxp1.lt.1, the routine will end with ier = 6. lenw - integer ( kind = 4 ) dimensioning parameter for work lenw must be at least leniw*2+maxp1*25. if lenw.lt.(leniw*2+maxp1*25), the routine will end with ier = 6.</p>
<p>work arrays iwork - integer ( kind = 4 ) vector of dimension at least leniw on return, iwork(k) for k = 1, 2, ..., lst contain the error flags on the cycles.</p>
<p>work - real ( kind = 8 ) vector of dimension at least lenw on return, work(1), ..., work(lst) contain the integral approximations over the cycles, work(limlst+1), ..., work(limlst+lst) contain the error extimates over the cycles. further elements of work have no specific meaning for the user. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l03958">3958</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a6882b990632eda53f07baf061905bff1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqawfe </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>integr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limlst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>maxp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limlst)&#160;</td>
          <td class="paramname"><em>rslst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limlst)&#160;</td>
          <td class="paramname"><em>erlst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limlst)&#160;</td>
          <td class="paramname"><em>ierlst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>lst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>alist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>blist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>rlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>elist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>iord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>nnlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(maxp1,25)&#160;</td>
          <td class="paramname"><em>chebmo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAWFE computes Fourier integrals. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given fourier integal i = integral of f(x)*w(x) over (a,infinity) where w(x)=cos(omega*x) or w(x)=sin(omega*x), hopefully satisfying following claim for accuracy abs(i-result).le.epsabs.</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>omega - real ( kind = 8 ) parameter in the weight function</p>
<p>integr - integer ( kind = 4 ) indicates which weight function is used integr = 1 w(x) = cos(omega*x) integr = 2 w(x) = sin(omega*x) if integr.ne.1.and.integr.ne.2, the routine will end with ier = 6.</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested, epsabs.gt.0 if epsabs.le.0, the routine will end with ier = 6.</p>
<p>limlst - integer ( kind = 4 ) limlst gives an upper bound on the number of cycles, limlst.ge.1. if limlst.lt.3, the routine will end with ier = 6.</p>
<p>limit - integer ( kind = 4 ) gives an upper bound on the number of subintervals allowed in the partition of each cycle, limit.ge.1 each cycle, limit.ge.1.</p>
<p>maxp1 - integer ( kind = 4 ) gives an upper bound on the number of chebyshev moments which can be stored, i.e. for the intervals of lengths abs(b-a)*2**(-l), l=0,1, ..., maxp1-2, maxp1.ge.1</p>
<p>on return result - real ( kind = 8 ) approximation to the integral x</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved. ier.gt.0 abnormal termination of the routine. the estimates for integral and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages if omega.ne.0 ier = 1 maximum number of cycles allowed has been achieved., i.e. of subintervals (a+(k-1)c,a+kc) where c = (2*int(abs(omega))+1)*pi/abs(omega), for k = 1, 2, ..., lst. one can allow more cycles by increasing the value of limlst (and taking the according dimension adjustments into account). examine the array iwork which contains the error flags on the cycles, in order to look for eventual local integration difficulties. if the position of a local difficulty can be determined (e.g. singularity, discontinuity within the interval) one will probably gain from splitting up the interval at this point and calling appropriate integrators on the subranges. = 4 the extrapolation table constructed for convergence acceleration of the series formed by the integral contributions over the cycles, does not converge to within the requested accuracy. as in the case of ier = 1, it is advised to examine the array iwork which contains the error flags on the cycles. = 6 the input is invalid because (integr.ne.1 and integr.ne.2) or epsabs.le.0 or limlst.lt.3. result, abserr, neval, lst are set to zero. = 7 bad integrand behaviour occurs within one or more of the cycles. location and type of the difficulty involved can be determined from the vector ierlst. here lst is the number of cycles actually needed (see below). ierlst(k) = 1 the maximum number of subdivisions (= limit) has been achieved on the k th cycle. = 2 occurrence of roundoff error is detected and prevents the tolerance imposed on the k th cycle, from being achieved. = 3 extremely bad integrand behaviour occurs at some points of the k th cycle. = 4 the integration procedure over the k th cycle does not converge (to within the required accuracy) due to roundoff in the extrapolation procedure invoked on this cycle. it is assumed that the result on this interval is the best which can be obtained. = 5 the integral over the k th cycle is probably divergent or slowly convergent. it must be noted that divergence can occur with any other value of ierlst(k). if omega = 0 and integr = 1, the integral is calculated by means of dqagie and ier = ierlst(1) (with meaning as described for ierlst(k), k = 1).</p>
<p>rslst - real ( kind = 8 ) vector of dimension at least limlst rslst(k) contains the integral contribution over the interval (a+(k-1)c,a+kc) where c = (2*int(abs(omega))+1)*pi/abs(omega), k = 1, 2, ..., lst. note that, if omega = 0, rslst(1) contains the value of the integral over (a,infinity).</p>
<p>erlst - real ( kind = 8 ) vector of dimension at least limlst erlst(k) contains the error estimate corresponding with rslst(k).</p>
<p>ierlst - integer ( kind = 4 ) vector of dimension at least limlst ierlst(k) contains the error flag corresponding with rslst(k). for the meaning of the local error flags see description of output parameter ier.</p>
<p>lst - integer ( kind = 4 ) number of subintervals needed for the integration if omega = 0 then lst is set to 1.</p>
<p>alist, blist, rlist, elist - real ( kind = 8 ) vector of dimension at least limit,</p>
<p>iord, nnlog - integer ( kind = 4 ) vector of dimension at least limit, providing space for the quantities needed in the subdivision process of each cycle</p>
<p>chebmo - real ( kind = 8 ) array of dimension at least (maxp1,25), providing space for the chebyshev moments needed within the cycles</p>
<p>Local Parameters: </p><pre class="fragment">the dimension of  psum  is determined by the value of
limexp in routine dqelg (psum must be of dimension
(limexp+2) at least).
</pre><p>c1, c2 - end points of subinterval (of length cycle) cycle - (2*int(abs(omega))+1)*pi/abs(omega) psum - vector of dimension at least (limexp+2) (see routine dqelg) psum contains the part of the epsilon table which is still needed for further computations. each element of psum is a partial sum of the series which should sum to the value of the integral. errsum - sum of error estimates over the subintervals, calculated cumulatively epsa - absolute tolerance requested over current subinterval chebmo - array containing the modified chebyshev moments (see also routine dqc25f) </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l03624">3624</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a95215b7ec043b06831f514b4a0f9bd47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqawo </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>integr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>leniw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>maxp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>lenw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(leniw)&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(lenw)&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAWO computes the integrals of oscillatory integrands. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given definite integral i=integral of f(x)*w(x) over (a,b) where w(x) = cos(omega*x) or w(x) = sin(omega*x), hopefully satisfying following claim for accuracy abs(i-result).le.max(epsabs,epsrel*abs(i)).</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration</p>
<p>omega - real ( kind = 8 ) parameter in the integrand weight function</p>
<p>integr - integer ( kind = 4 ) indicates which of the weight functions is used integr = 1 w(x) = cos(omega*x) integr = 2 w(x) = sin(omega*x) if integr.ne.1.and.integr.ne.2, the routine will end with ier = 6.</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested epsrel - real ( kind = 8 ) relative accuracy requested if epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), the routine will end with ier = 6.</p>
<p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved.</p><ul>
<li>ier.gt.0 abnormal termination of the routine. the estimates for integral and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages ier = 1 maximum number of subdivisions allowed (= leniw/2) has been achieved. one can allow more subdivisions by increasing the value of leniw (and taking the according dimension adjustments into account). however, if this yields no improvement it is advised to analyze the integrand in order to determine the integration difficulties. if the position of a local difficulty can be determined (e.g. singularity, discontinuity within the interval) one will probably gain from splitting up the interval at this point and calling the integrator on the subranges. if possible, an appropriate special-purpose integrator should be used which is designed for handling the type of difficulty involved. = 2 the occurrence of roundoff error is detected, which prevents the requested tolerance from being achieved. the error may be under-estimated. = 3 extremely bad integrand behaviour occurs at some interior points of the integration interval. = 4 the algorithm does not converge. roundoff error is detected in the extrapolation table. it is presumed that the requested tolerance cannot be achieved due to roundoff in the extrapolation table, and that the returned result is the best which can be obtained. = 5 the integral is probably divergent, or slowly convergent. it must be noted that divergence can occur with any other value of ier. = 6 the input is invalid, because (epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28)) or (integr.ne.1 and integr.ne.2), or leniw.lt.2 or maxp1.lt.1 or lenw.lt.leniw*2+maxp1*25. result, abserr, neval, last are set to zero. except when leniw, maxp1 or lenw are invalid, work(limit*2+1), work(limit*3+1), iwork(1), iwork(limit+1) are set to zero, work(1) is set to a and work(limit+1) to b.</li>
</ul>
<p>dimensioning parameters leniw - integer ( kind = 4 ) dimensioning parameter for iwork. leniw/2 equals the maximum number of subintervals allowed in the partition of the given integration interval (a,b), leniw.ge.2. if leniw.lt.2, the routine will end with ier = 6.</p>
<p>maxp1 - integer ( kind = 4 ) gives an upper bound on the number of chebyshev moments which can be stored, i.e. for the intervals of lengths abs(b-a)*2**(-l), l=0,1, ..., maxp1-2, maxp1.ge.1 if maxp1.lt.1, the routine will end with ier = 6.</p>
<p>lenw - integer ( kind = 4 ) dimensioning parameter for work lenw must be at least leniw*2+maxp1*25. if lenw.lt.(leniw*2+maxp1*25), the routine will end with ier = 6.</p>
<p>last - integer ( kind = 4 ) on return, last equals the number of subintervals produced in the subdivision process, which determines the number of significant elements actually in the work arrays.</p>
<p>work arrays iwork - integer ( kind = 4 ) vector of dimension at least leniw on return, the first k elements of which contain pointers to the error estimates over the subintervals, such that work(limit*3+iwork(1)), .. work(limit*3+iwork(k)) form a decreasing sequence, with limit = lenw/2 , and k = last if last.le.(limit/2+2), and k = limit+1-last otherwise. furthermore, iwork(limit+1), ..., iwork(limit+ last) indicate the subdivision levels of the subintervals, such that iwork(limit+i) = l means that the subinterval numbered i is of length abs(b-a)*2**(1-l).</p>
<p>work - real ( kind = 8 ) vector of dimension at least lenw on return work(1), ..., work(last) contain the left end points of the subintervals in the partition of (a,b), work(limit+1), ..., work(limit+last) contain the right end points, work(limit*2+1), ..., work(limit*2+last) contain the integral approximations over the subintervals, work(limit*3+1), ..., work(limit*3+last) contain the error estimates. work(limit*4+1), ..., work(limit*4+maxp1*25) provide space for storing the chebyshev moments. note that limit = lenw/2. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l04727">4727</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a346b54be67ae642afb55e08eb32dcd6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqawoe </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>integr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>icall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>maxp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>alist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>blist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>rlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>elist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>iord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>nnlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>momcom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(maxp1,25)&#160;</td>
          <td class="paramname"><em>chebmo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAWOE computes the integrals of oscillatory integrands. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given definite integral i = integral of f(x)*w(x) over (a,b) where w(x) = cos(omega*x) or w(x)=sin(omega*x), hopefully satisfying following claim for accuracy abs(i-result).le.max(epsabs,epsrel*abs(i)).</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration</p>
<p>omega - real ( kind = 8 ) parameter in the integrand weight function</p>
<p>integr - integer ( kind = 4 ) indicates which of the weight functions is to be used integr = 1 w(x) = cos(omega*x) integr = 2 w(x) = sin(omega*x) if integr.ne.1 and integr.ne.2, the routine will end with ier = 6.</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested epsrel - real ( kind = 8 ) relative accuracy requested if epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), the routine will end with ier = 6.</p>
<p>limit - integer ( kind = 4 ) gives an upper bound on the number of subdivisions in the partition of (a,b), limit.ge.1.</p>
<p>icall - integer ( kind = 4 ) if dqawoe is to be used only once, icall must be set to 1. assume that during this call, the chebyshev moments (for clenshaw-curtis integration of degree 24) have been computed for intervals of lenghts (abs(b-a))*2**(-l), l=0,1,2,...momcom-1. if icall.gt.1 this means that dqawoe has been called twice or more on intervals of the same length abs(b-a). the chebyshev moments already computed are then re-used in subsequent calls. if icall.lt.1, the routine will end with ier = 6.</p>
<p>maxp1 - integer ( kind = 4 ) gives an upper bound on the number of chebyshev moments which can be stored, i.e. for the intervals of lenghts abs(b-a)*2**(-l), l=0,1, ..., maxp1-2, maxp1.ge.1. if maxp1.lt.1, the routine will end with ier = 6.</p>
<p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved.</p><ul>
<li>ier.gt.0 abnormal termination of the routine. the estimates for integral and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages ier = 1 maximum number of subdivisions allowed has been achieved. one can allow more subdivisions by increasing the value of limit (and taking according dimension adjustments into account). however, if this yields no improvement it is advised to analyze the integrand, in order to determine the integration difficulties. if the position of a local difficulty can be determined (e.g. singularity, discontinuity within the interval) one will probably gain from splitting up the interval at this point and calling the integrator on the subranges. if possible, an appropriate special-purpose integrator should be used which is designed for handling the type of difficulty involved. = 2 the occurrence of roundoff error is detected, which prevents the requested tolerance from being achieved. the error may be under-estimated. = 3 extremely bad integrand behaviour occurs at some points of the integration interval. = 4 the algorithm does not converge. roundoff error is detected in the extrapolation table. it is presumed that the requested tolerance cannot be achieved due to roundoff in the extrapolation table, and that the returned result is the best which can be obtained. = 5 the integral is probably divergent, or slowly convergent. it must be noted that divergence can occur with any other value of ier.gt.0. = 6 the input is invalid, because (epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28)) or (integr.ne.1 and integr.ne.2) or icall.lt.1 or maxp1.lt.1. result, abserr, neval, last, rlist(1), elist(1), iord(1) and nnlog(1) are set to zero. alist(1) and blist(1) are set to a and b respectively.</li>
</ul>
<p>last - integer ( kind = 4 ) on return, last equals the number of subintervals produces in the subdivision process, which determines the number of significant elements actually in the work arrays. alist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the left end points of the subintervals in the partition of the given integration range (a,b)</p>
<p>blist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the right end points of the subintervals in the partition of the given integration range (a,b)</p>
<p>rlist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the integral approximations on the subintervals</p>
<p>elist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the moduli of the absolute error estimates on the subintervals</p>
<p>iord - integer ( kind = 4 ) vector of dimension at least limit, the first k elements of which are pointers to the error estimates over the subintervals, such that elist(iord(1)), ..., elist(iord(k)) form a decreasing sequence, with k = last if last.le.(limit/2+2), and k = limit+1-last otherwise.</p>
<p>nnlog - integer ( kind = 4 ) vector of dimension at least limit, containing the subdivision levels of the subintervals, i.e. iwork(i) = l means that the subinterval numbered i is of length abs(b-a)*2**(1-l)</p>
<p>on entry and return momcom - integer ( kind = 4 ) indicating that the chebyshev moments have been computed for intervals of lengths (abs(b-a))*2**(-l), l=0,1,2, ..., momcom-1, momcom.lt.maxp1</p>
<p>chebmo - real ( kind = 8 ) array of dimension (maxp1,25) containing the chebyshev moments</p>
<p>Local Parameters: </p><pre class="fragment">the dimension of rlist2 is determined by  the value of
limexp in routine dqelg (rlist2 should be of
dimension (limexp+2) at least).

list of major variables
</pre><p>alist - list of left end points of all subintervals considered up to now blist - list of right end points of all subintervals considered up to now rlist(i) - approximation to the integral over (alist(i),blist(i)) rlist2 - array of dimension at least limexp+2 containing the part of the epsilon table which is still needed for further computations elist(i) - error estimate applying to rlist(i) maxerr - pointer to the interval with largest error estimate errmax - elist(maxerr) erlast - error on the interval currently subdivided area - sum of the integrals over the subintervals errsum - sum of the errors over the subintervals errbnd - requested accuracy max(epsabs,epsrel* abs(result)) *****1 - variable for the left subinterval *****2 - variable for the right subinterval last - index for subdivision nres - number of calls to the extrapolation routine numrl2 - number of elements in rlist2. if an appropriate approximation to the compounded integral has been obtained it is put in rlist2(numrl2) after numrl2 has been increased by one small - length of the smallest interval considered up to now, multiplied by 1.5 erlarg - sum of the errors over the intervals larger than the smallest interval considered up to now extrap - logical variable denoting that the routine is attempting to perform extrapolation, i.e. before subdividing the smallest interval we try to decrease the value of erlarg noext - logical variable denoting that extrapolation is no longer allowed (true value)</p>
<p>machine dependent constants</p>
<p>epmach is the largest relative spacing. uflow is the smallest positive magnitude. oflow is the largest positive magnitude. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l04272">4272</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a8b769affa04c358c29231bb9befab4be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqaws </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>alfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>integr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>lenw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>iwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(lenw)&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAWS estimates integrals with algebraico-logarithmic endpoint singularities. </p>
<p>Modified:</p>
<p>12 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given definite integral i = integral of f*w over (a,b), (where w shows a singular behaviour at the end points see parameter integr). hopefully satisfying following claim for accuracy abs(i-result).le.max(epsabs,epsrel*abs(i)).</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration, b.gt.a if b.le.a, the routine will end with ier = 6.</p>
<p>alfa - real ( kind = 8 ) parameter in the integrand function, alfa.gt.(-1) if alfa.le.(-1), the routine will end with ier = 6.</p>
<p>beta - real ( kind = 8 ) parameter in the integrand function, beta.gt.(-1) if beta.le.(-1), the routine will end with ier = 6.</p>
<p>integr - integer ( kind = 4 ) indicates which weight function is to be used = 1 (x-a)**alfa*(b-x)**beta = 2 (x-a)**alfa*(b-x)**beta*log(x-a) = 3 (x-a)**alfa*(b-x)**beta*log(b-x) = 4 (x-a)**alfa*(b-x)**beta*log(x-a)*log(b-x) if integr.lt.1 or integr.gt.4, the routine will end with ier = 6.</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested epsrel - real ( kind = 8 ) relative accuracy requested if epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), the routine will end with ier = 6.</p>
<p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved. ier.gt.0 abnormal termination of the routine the estimates for the integral and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages ier = 1 maximum number of subdivisions allowed has been achieved. one can allow more subdivisions by increasing the value of limit (and taking the according dimension adjustments into account). however, if this yields no improvement it is advised to analyze the integrand, in order to determine the integration difficulties which prevent the requested tolerance from being achieved. in case of a jump discontinuity or a local singularity of algebraico-logarithmic type at one or more interior points of the integration range, one should proceed by splitting up the interval at these points and calling the integrator on the subranges. = 2 the occurrence of roundoff error is detected, which prevents the requested tolerance from being achieved. = 3 extremely bad integrand behaviour occurs at some points of the integration interval. = 6 the input is invalid, because b.le.a or alfa.le.(-1) or beta.le.(-1) or or integr.lt.1 or integr.gt.4 or (epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28)) or limit.lt.2 or lenw.lt.limit*4. result, abserr, neval, last are set to zero. except when lenw or limit is invalid iwork(1), work(limit*2+1) and work(limit*3+1) are set to zero, work(1) is set to a and work(limit+1) to b.</p>
<p>dimensioning parameters limit - integer ( kind = 4 ) dimensioning parameter for iwork limit determines the maximum number of subintervals in the partition of the given integration interval (a,b), limit.ge.2. if limit.lt.2, the routine will end with ier = 6.</p>
<p>lenw - integer ( kind = 4 ) dimensioning parameter for work lenw must be at least limit*4. if lenw.lt.limit*4, the routine will end with ier = 6.</p>
<p>last - integer ( kind = 4 ) on return, last equals the number of subintervals produced in the subdivision process, which determines the significant number of elements actually in the work arrays.</p>
<p>work arrays iwork - integer ( kind = 4 ) vector of dimension limit, the first k elements of which contain pointers to the error estimates over the subintervals, such that work(limit*3+iwork(1)), ..., work(limit*3+iwork(k)) form a decreasing sequence with k = last if last.le.(limit/2+2), and k = limit+1-last otherwise</p>
<p>work - real ( kind = 8 ) vector of dimension lenw on return work(1), ..., work(last) contain the left end points of the subintervals in the partition of (a,b), work(limit+1), ..., work(limit+last) contain the right end points, work(limit*2+1), ..., work(limit*2+last) contain the integral approximations over the subintervals, work(limit*3+1), ..., work(limit*3+last) contain the error estimates. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l05307">5307</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a557929bd4f601dc16fe580f11344b0b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqawse </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>alfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>integr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>alist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>blist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>rlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>elist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(limit)&#160;</td>
          <td class="paramname"><em>iord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQAWSE estimates integrals with algebraico-logarithmic end singularities. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given definite integral i = integral of f*w over (a,b), (where w shows a singular behaviour at the end points, see parameter integr). hopefully satisfying following claim for accuracy abs(i-result).le.max(epsabs,epsrel*abs(i)).</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration, b.gt.a if b.le.a, the routine will end with ier = 6.</p>
<p>alfa - real ( kind = 8 ) parameter in the weight function, alfa.gt.(-1) if alfa.le.(-1), the routine will end with ier = 6.</p>
<p>beta - real ( kind = 8 ) parameter in the weight function, beta.gt.(-1) if beta.le.(-1), the routine will end with ier = 6.</p>
<p>integr - integer ( kind = 4 ) indicates which weight function is to be used = 1 (x-a)**alfa*(b-x)**beta = 2 (x-a)**alfa*(b-x)**beta*log(x-a) = 3 (x-a)**alfa*(b-x)**beta*log(b-x) = 4 (x-a)**alfa*(b-x)**beta*log(x-a)*log(b-x) if integr.lt.1 or integr.gt.4, the routine will end with ier = 6.</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested epsrel - real ( kind = 8 ) relative accuracy requested if epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), the routine will end with ier = 6.</p>
<p>limit - integer ( kind = 4 ) gives an upper bound on the number of subintervals in the partition of (a,b), limit.ge.2 if limit.lt.2, the routine will end with ier = 6.</p>
<p>on return result - real ( kind = 8 ) approximation to the integral</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - integer ( kind = 4 ) ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved. ier.gt.0 abnormal termination of the routine the estimates for the integral and error are less reliable. it is assumed that the requested accuracy has not been achieved. error messages = 1 maximum number of subdivisions allowed has been achieved. one can allow more subdivisions by increasing the value of limit. however, if this yields no improvement, it is advised to analyze the integrand in order to determine the integration difficulties which prevent the requested tolerance from being achieved. in case of a jump discontinuity or a local singularity of algebraico-logarithmic type at one or more interior points of the integration range, one should proceed by splitting up the interval at these points and calling the integrator on the subranges. = 2 the occurrence of roundoff error is detected, which prevents the requested tolerance from being achieved. = 3 extremely bad integrand behaviour occurs at some points of the integration interval. = 6 the input is invalid, because b.le.a or alfa.le.(-1) or beta.le.(-1), or integr.lt.1 or integr.gt.4, or (epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), or limit.lt.2. result, abserr, neval, rlist(1), elist(1), iord(1) and last are set to zero. alist(1) and blist(1) are set to a and b respectively.</p>
<p>alist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the left end points of the subintervals in the partition of the given integration range (a,b)</p>
<p>blist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the right end points of the subintervals in the partition of the given integration range (a,b)</p>
<p>rlist - real ( kind = 8 ) vector of dimension at least limit,the first last elements of which are the integral approximations on the subintervals</p>
<p>elist - real ( kind = 8 ) vector of dimension at least limit, the first last elements of which are the moduli of the absolute error estimates on the subintervals</p>
<p>iord - integer ( kind = 4 ) vector of dimension at least limit, the first k of which are pointers to the error estimates over the subintervals, so that elist(iord(1)), ..., elist(iord(k)) with k = last if last.le.(limit/2+2), and k = limit+1-last otherwise form a decreasing sequence</p>
<p>last - integer ( kind = 4 ) number of subintervals actually produced in the subdivision process</p>
<p>Local parameters:</p>
<p>alist - list of left end points of all subintervals considered up to now blist - list of right end points of all subintervals considered up to now rlist(i) - approximation to the integral over (alist(i),blist(i)) elist(i) - error estimate applying to rlist(i) maxerr - pointer to the interval with largest error estimate errmax - elist(maxerr) area - sum of the integrals over the subintervals errsum - sum of the errors over the subintervals errbnd - requested accuracy max(epsabs,epsrel* abs(result)) *****1 - variable for the left subinterval *****2 - variable for the right subinterval last - index for subdivision</p>
<p>machine dependent constants</p>
<p>epmach is the largest relative spacing. uflow is the smallest positive magnitude. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l04949">4949</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a407a3ddbb554adffce61182ace3c2a3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqc25c </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>krul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQC25C returns integration rules for Cauchy Principal Value integrals. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose to compute i = integral of f*w over (a,b) with error estimate, where w(x) = 1/(x-c)</p>
<p>Parameters:</p>
<p>f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) left end point of the integration interval</p>
<p>b - real ( kind = 8 ) right end point of the integration interval, b.gt.a</p>
<p>c - real ( kind = 8 ) parameter in the weight function</p>
<p>result - real ( kind = 8 ) approximation to the integral result is computed by using a generalized clenshaw-curtis method if c lies within ten percent of the integration interval. in the other case the 15-point kronrod rule obtained by optimal addition of abscissae to the 7-point gauss rule, is applied.</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>krul - integer ( kind = 4 ) key which is decreased by 1 if the 15-point gauss-kronrod scheme has been used</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>Local Parameters:</p>
<p>fval - value of the function f at the points cos(k*pi/24), k = 0, ..., 24 cheb12 - chebyshev series expansion coefficients, for the function f, of degree 12 cheb24 - chebyshev series expansion coefficients, for the function f, of degree 24 res12 - approximation to the integral corresponding to the use of cheb12 res24 - approximation to the integral corresponding to the use of cheb24 dqwgtc - external function subprogram defining the weight function hlgth - half-length of the interval centr - mid point of the interval</p>
<p>the vector x contains the values cos(k*pi/24), k = 1, ..., 11, to be used for the chebyshev series expansion of f </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l05415">5415</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="afd4247cf39044166b3bf199ea9fee695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqc25f </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>integr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>nrmom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>maxp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ksave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resasc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>momcom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(maxp1,25)&#160;</td>
          <td class="paramname"><em>chebmo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQC25F returns integration rules for functions with a COS or SIN factor. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose to compute the integral i=integral of f(x) over (a,b) where w(x) = cos(omega*x) or w(x)=sin(omega*x) and to compute j = integral of abs(f) over (a,b). for small value of omega or small intervals (a,b) the 15-point gauss-kronro rule is used. otherwise a generalized clenshaw-curtis method is used.</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the calling program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration</p>
<p>omega - real ( kind = 8 ) parameter in the weight function</p>
<p>integr - integer ( kind = 4 ) indicates which weight function is to be used integr = 1 w(x) = cos(omega*x) integr = 2 w(x) = sin(omega*x)</p>
<p>nrmom - integer ( kind = 4 ) the length of interval (a,b) is equal to the length of the original integration interval divided by 2**nrmom (we suppose that the routine is used in an adaptive integration process, otherwise set nrmom = 0). nrmom must be zero at the first call.</p>
<p>maxp1 - integer ( kind = 4 ) gives an upper bound on the number of chebyshev moments which can be stored, i.e. for the intervals of lengths abs(bb-aa)*2**(-l), l = 0,1,2, ..., maxp1-2.</p>
<p>ksave - integer ( kind = 4 ) key which is one when the moments for the current interval have been computed</p>
<p>on return result - real ( kind = 8 ) approximation to the integral i</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>resabs - real ( kind = 8 ) approximation to the integral j</p>
<p>resasc - real ( kind = 8 ) approximation to the integral of abs(f-i/(b-a))</p>
<p>on entry and return momcom - integer ( kind = 4 ) for each interval length we need to compute the chebyshev moments. momcom counts the number of intervals for which these moments have already been computed. if nrmom.lt.momcom or ksave = 1, the chebyshev moments for the interval (a,b) have already been computed and stored, otherwise we compute them and we increase momcom.</p>
<p>chebmo - real ( kind = 8 ) array of dimension at least (maxp1,25) containing the modified chebyshev moments for the first momcom momcom interval lengths</p>
<p>Local Parameters:</p>
<p>the vector x contains the values cos(k*pi/24) k = 1, ...,11, to be used for the chebyshev expansion of f</p>
<p>centr - mid point of the integration interval hlgth - half-length of the integration interval fval - value of the function f at the points (b-a)*0.5*cos(k*pi/12) + (b+a)*0.5, k = 0, ..., 24 cheb12 - coefficients of the chebyshev series expansion of degree 12, for the function f, in the interval (a,b) cheb24 - coefficients of the chebyshev series expansion of degree 24, for the function f, in the interval (a,b) resc12 - approximation to the integral of cos(0.5*(b-a)*omega*x)*f(0.5*(b-a)*x+0.5*(b+a)) over (-1,+1), using the chebyshev series expansion of degree 12 resc24 - approximation to the same integral, using the chebyshev series expansion of degree 24 ress12 - the analogue of resc12 for the sine ress24 - the analogue of resc24 for the sine</p>
<pre class="fragment"> machine dependent constant

 oflow is the largest positive magnitude.</pre> 
<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l05626">5626</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a5e2263d56378a59e2b0d217f6fb6fd62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqc25s </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>br</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>alfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(25)&#160;</td>
          <td class="paramname"><em>ri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(25)&#160;</td>
          <td class="paramname"><em>rj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(25)&#160;</td>
          <td class="paramname"><em>rg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(25)&#160;</td>
          <td class="paramname"><em>rh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resasc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>integr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>nev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQC25S returns rules for algebraico-logarithmic end point singularities. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose to compute i = integral of f*w over (bl,br), with error estimate, where the weight function w has a singular behaviour of algebraico-logarithmic type at the points a and/or b. (bl,br) is a part of (a,b).</p>
<p>Parameters:</p>
<p>f - real ( kind = 8 ) function subprogram defining the integrand f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) left end point of the original interval</p>
<p>b - real ( kind = 8 ) right end point of the original interval, b.gt.a</p>
<p>bl - real ( kind = 8 ) lower limit of integration, bl.ge.a</p>
<p>br - real ( kind = 8 ) upper limit of integration, br.le.b</p>
<p>alfa - real ( kind = 8 ) parameter in the weight function</p>
<p>beta - real ( kind = 8 ) parameter in the weight function</p>
<p>ri,rj,rg,rh - real ( kind = 8 ) modified chebyshev moments for the application of the generalized clenshaw-curtis method (computed in routine dqmomo)</p>
<p>result - real ( kind = 8 ) approximation to the integral result is computed by using a generalized clenshaw-curtis method if b1 = a or br = b. in all other cases the 15-point kronrod rule is applied, obtained by optimal addition of abscissae to the 7-point gauss rule.</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>resasc - real ( kind = 8 ) approximation to the integral of abs(f*w-i/(b-a))</p>
<p>integr - integer ( kind = 4 ) which determines the weight function = 1 w(x) = (x-a)**alfa*(b-x)**beta = 2 w(x) = (x-a)**alfa*(b-x)**beta*log(x-a) = 3 w(x) = (x-a)**alfa*(b-x)**beta*log(b-x) = 4 w(x) = (x-a)**alfa*(b-x)**beta*log(x-a)* log(b-x)</p>
<p>nev - integer ( kind = 4 ) number of integrand evaluations</p>
<p>Local Parameters:</p>
<p>the vector x contains the values cos(k*pi/24) k = 1, ..., 11, to be used for the computation of the chebyshev series expansion of f.</p>
<p>fval - value of the function f at the points (br-bl)*0.5*cos(k*pi/24)+(br+bl)*0.5 k = 0, ..., 24 cheb12 - coefficients of the chebyshev series expansion of degree 12, for the function f, in the interval (bl,br) cheb24 - coefficients of the chebyshev series expansion of degree 24, for the function f, in the interval (bl,br) res12 - approximation to the integral obtained from cheb12 res24 - approximation to the integral obtained from cheb24 dqwgts - external function subprogram defining the four possible weight functions hlgth - half-length of the interval (bl,br) centr - mid point of the interval (bl,br) </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l05955">5955</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="affb695f1ae958c0501668ace0493b525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqcheb </td>
          <td>(</td>
          <td class="paramtype">real ( kind = 8 ), dimension(11)&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(25)&#160;</td>
          <td class="paramname"><em>fval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(13)&#160;</td>
          <td class="paramname"><em>cheb12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(25)&#160;</td>
          <td class="paramname"><em>cheb24</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQCHEB computes the Chebyshev series expansion. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose this routine computes the chebyshev series expansion of degrees 12 and 24 of a function using a fast fourier transform method f(x) = sum(k=1,..,13) (cheb12(k)*t(k-1,x)), f(x) = sum(k=1,..,25) (cheb24(k)*t(k-1,x)), where t(k,x) is the chebyshev polynomial of degree k.</p>
<p>Parameters:</p>
<p>on entry x - real ( kind = 8 ) vector of dimension 11 containing the values cos(k*pi/24), k = 1, ..., 11</p>
<p>fval - real ( kind = 8 ) vector of dimension 25 containing the function values at the points (b+a+(b-a)*cos(k*pi/24))/2, k = 0, ...,24, where (a,b) is the approximation interval. fval(1) and fval(25) are divided by two (these values are destroyed at output).</p>
<p>on return cheb12 - real ( kind = 8 ) vector of dimension 13 containing the chebyshev coefficients for degree 12</p>
<p>cheb24 - real ( kind = 8 ) vector of dimension 25 containing the chebyshev coefficients for degree 24 </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l06245">6245</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ae1c52ea129afde075283ccbd2241b1cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqelg </td>
          <td>(</td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(52)&#160;</td>
          <td class="paramname"><em>epstab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(3)&#160;</td>
          <td class="paramname"><em>res3la</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>nres</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQELG carries out the Epsilon extrapolation algorithm. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine determines the limit of a given sequence of approximations, by means of the epsilon algorithm of p.wynn. an estimate of the absolute error is also given. the condensed epsilon table is computed. only those elements needed for the computation of the next diagonal are preserved.</p>
<p>Parameters: </p><pre class="fragment">  n      - integer ( kind = 4 )
           epstab(n) contains the new element in the
           first column of the epsilon table.

  epstab - real ( kind = 8 )
           vector of dimension 52 containing the elements
           of the two lower diagonals of the triangular
           epsilon table. the elements are numbered
           starting at the right-hand corner of the
           triangle.

  result - real ( kind = 8 )
           resulting approximation to the integral

  abserr - real ( kind = 8 )
           estimate of the absolute error computed from
           result and the 3 previous results

  res3la - real ( kind = 8 )
           vector of dimension 3 containing the last 3
           results

  nres   - integer ( kind = 4 )
           number of calls to the routine
           (should be zero at first call)
</pre><p>Local Parameters:</p>
<p>e0 - the 4 elements on which the computation of a new e1 element in the epsilon table is based e2 e3 e0 e3 e1 new e2 newelm - number of elements to be computed in the new diagonal error - error = abs(e1-e0)+abs(e2-e1)+abs(new-e2) result - the element in the new diagonal with least value of error</p>
<p>machine dependent constants</p>
<p>epmach is the largest relative spacing. oflow is the largest positive magnitude. limexp is the maximum number of elements the epsilon table can contain. if this number is reached, the upper diagonal of the epsilon table is deleted. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l06430">6430</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a22a30b889695823050f4f6c588454bbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqk15 </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resasc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQK15 carries out a 15 point Gauss-Kronrod quadrature rule. </p>
<p>the abscissae and weights are given for the interval (-1,1). because of symmetry only the positive abscissae and their corresponding weights are given.</p>
<p>xgk - abscissae of the 15-point kronrod rule xgk(2), xgk(4), ... abscissae of the 7-point gauss rule xgk(1), xgk(3), ... abscissae which are optimally added to the 7-point gauss rule</p>
<p>wgk - weights of the 15-point kronrod rule</p>
<p>wg - weights of the 7-point gauss rule</p>
<p>gauss quadrature weights and kronron quadrature abscissae and weights as evaluated with 80 decimal digit arithmetic by l. w. fullerton, bell labs, nov. 1981.</p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose to compute i = integral of f over (a,b), with error estimate j = integral of abs(f) over (a,b) Parameters: </p><pre class="fragment">on entry
  f      - real ( kind = 8 )
           function subprogram defining the integrand
           function f(x). the actual name for f needs to be
           declared e x t e r n a l in the calling program.

  a      - real ( kind = 8 )
           lower limit of integration

  b      - real ( kind = 8 )
           upper limit of integration

on return
  result - real ( kind = 8 )
           approximation to the integral i
           result is computed by applying the 15-point
           kronrod rule (resk) obtained by optimal addition
           of abscissae to the7-point gauss rule(resg).

  abserr - real ( kind = 8 )
           estimate of the modulus of the absolute error,
           which should not exceed abs(i-result)

  resabs - real ( kind = 8 )
           approximation to the integral j

  resasc - real ( kind = 8 )
           approximation to the integral of abs(f-i/(b-a))
           over (a,b)
</pre><p>Local Parameters:</p>
<p>centr - mid point of the interval hlgth - half-length of the interval absc - abscissa fval* - function value resg - result of the 7-point gauss formula resk - result of the 15-point kronrod formula reskh - approximation to the mean value of f over (a,b), i.e. to i/(b-a)</p>
<p>machine dependent constants</p>
<p>epmach is the largest relative spacing. uflow is the smallest positive magnitude. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l06630">6630</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a266d8ac79996877b9c031b36eb31d21a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqk15i </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>boun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>inf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resasc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQK15I applies a 15 point Gauss-Kronrod quadrature on an infinite interval. </p>
<p>the abscissae and weights are supplied for the interval (-1,1). because of symmetry only the positive abscissae and their corresponding weights are given.</p>
<p>xgk - abscissae of the 15-point kronrod rule xgk(2), xgk(4), ... abscissae of the 7-point gauss rule xgk(1), xgk(3), ... abscissae which are optimally added to the 7-point gauss rule</p>
<p>wgk - weights of the 15-point kronrod rule</p>
<p>wg - weights of the 7-point gauss rule, corresponding to the abscissae xgk(2), xgk(4), ... wg(1), wg(3), ... are set to zero.</p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the original (infinite integration range is mapped onto the interval (0,1) and (a,b) is a part of (0,1). it is the purpose to compute i = integral of transformed integrand over (a,b), j = integral of abs(transformed integrand) over (a,b).</p>
<p>Parameters: </p><pre class="fragment">on entry
  f      - real ( kind = 8 )
           fuction subprogram defining the integrand
           function f(x). the actual name for f needs to be
           declared e x t e r n a l in the calling program.

  boun   - real ( kind = 8 )
           finite bound of original integration
           range (set to zero if inf = +2)

  inf    - integer ( kind = 4 )
           if inf = -1, the original interval is
                       (-infinity,bound),
           if inf = +1, the original interval is
                       (bound,+infinity),
           if inf = +2, the original interval is
                       (-infinity,+infinity) and
           the integral is computed as the sum of two
           integrals, one over (-infinity,0) and one over
           (0,+infinity).

  a      - real ( kind = 8 )
           lower limit for integration over subrange
           of (0,1)

  b      - real ( kind = 8 )
           upper limit for integration over subrange
           of (0,1)

on return
  result - real ( kind = 8 )
           approximation to the integral i
           result is computed by applying the 15-point
           kronrod rule(resk) obtained by optimal addition
           of abscissae to the 7-point gauss rule(resg).

  abserr - real ( kind = 8 )
           estimate of the modulus of the absolute error,
           which should equal or exceed abs(i-result)

  resabs - real ( kind = 8 )
           approximation to the integral j

  resasc - real ( kind = 8 )
           approximation to the integral of
           abs((transformed integrand)-i/(b-a)) over (a,b)
</pre><p>Local Parameters:</p>
<p>centr - mid point of the interval hlgth - half-length of the interval absc* - abscissa tabsc* - transformed abscissa fval* - function value resg - result of the 7-point gauss formula resk - result of the 15-point kronrod formula reskh - approximation to the mean value of the transformed integrand over (a,b), i.e. to i/(b-a)</p>
<p>machine dependent constants</p>
<p>epmach is the largest relative spacing. uflow is the smallest positive magnitude. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l06821">6821</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a1d7cf1b13718541591e860c6e822b63f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqk15w </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>kp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resasc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQK15W applies a 15 point Gauss-Kronrod rule for a weighted integrand. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose to compute i = integral of f*w over (a,b), with error estimate j = integral of abs(f*w) over (a,b)</p>
<p>Parameters: </p><pre class="fragment"> on entry
  f      - real ( kind = 8 )
           function subprogram defining the integrand
           function f(x). the actual name for f needs to be
           declared e x t e r n a l in the driver program.

  w      - real ( kind = 8 )
           function subprogram defining the integrand
           weight function w(x). the actual name for w
           needs to be declared e x t e r n a l in the
           calling program.

  p1, p2, p3, p4 - real ( kind = 8 )
           parameters in the weight function

  kp     - integer ( kind = 4 )
           key for indicating the type of weight function

  a      - real ( kind = 8 )
           lower limit of integration

  b      - real ( kind = 8 )
           upper limit of integration

on return
  result - real ( kind = 8 )
           approximation to the integral i
           result is computed by applying the 15-point
           kronrod rule (resk) obtained by optimal addition
           of abscissae to the 7-point gauss rule (resg).

  abserr - real ( kind = 8 )
           estimate of the modulus of the absolute error,
           which should equal or exceed abs(i-result)

  resabs - real ( kind = 8 )
           approximation to the integral of abs(f)

  resasc - real ( kind = 8 )
           approximation to the integral of abs(f-i/(b-a))
</pre><p>Local Parameters:</p>
<p>the abscissae and weights are given for the interval (-1,1). because of symmetry only the positive abscissae and their corresponding weights are given.</p>
<p>xgk - abscissae of the 15-point gauss-kronrod rule xgk(2), xgk(4), ... abscissae of the 7-point gauss rule xgk(1), xgk(3), ... abscissae which are optimally added to the 7-point gauss rule</p>
<p>wgk - weights of the 15-point gauss-kronrod rule</p>
<p>wg - weights of the 7-point gauss rule</p>
<p>centr - mid point of the interval hlgth - half-length of the interval absc* - abscissa fval* - function value resg - result of the 7-point gauss formula resk - result of the 15-point kronrod formula reskh - approximation to the mean value of f*w over (a,b), i.e. to i/(b-a)</p>
<p>machine dependent constants</p>
<p>epmach is the largest relative spacing. uflow is the smallest positive magnitude. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l07004">7004</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a4818db594c6e4b4ab9d8572f022a6ffa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqk21 </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resasc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQK21 carries out a 21 point Gauss-Kronrod quadrature rule. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose to compute i = integral of f over (a,b), with error estimate j = integral of abs(f) over (a,b)</p>
<p>Parameters: </p><pre class="fragment">on entry
  f      - real ( kind = 8 )
           function subprogram defining the integrand
           function f(x). the actual name for f needs to be
           declared e x t e r n a l in the driver program.

  a      - real ( kind = 8 )
           lower limit of integration

  b      - real ( kind = 8 )
           upper limit of integration

on return
  result - real ( kind = 8 )
           approximation to the integral i
           result is computed by applying the 21-point
           kronrod rule (resk) obtained by optimal addition
           of abscissae to the 10-point gauss rule (resg).

  abserr - real ( kind = 8 )
           estimate of the modulus of the absolute error,
           which should not exceed abs(i-result)

  resabs - real ( kind = 8 )
           approximation to the integral j

  resasc - real ( kind = 8 )
           approximation to the integral of abs(f-i/(b-a))
           over (a,b)
</pre><p>Local Parameters:</p>
<pre class="fragment"> the abscissae and weights are given for the interval (-1,1).
 because of symmetry only the positive abscissae and their
 corresponding weights are given.

 xgk    - abscissae of the 21-point kronrod rule
          xgk(2), xgk(4), ...  abscissae of the 10-point
          gauss rule
          xgk(1), xgk(3), ...  abscissae which are optimally
          added to the 10-point gauss rule

 wgk    - weights of the 21-point kronrod rule

 wg     - weights of the 10-point gauss rule
</pre><p>gauss quadrature weights and kronron quadrature abscissae and weights as evaluated with 80 decimal digit arithmetic by l. w. fullerton, bell labs, nov. 1981. </p><pre class="fragment">centr  - mid point of the interval
hlgth  - half-length of the interval
absc   - abscissa
fval*  - function value
resg   - result of the 10-point gauss formula
resk   - result of the 21-point kronrod formula
reskh  - approximation to the mean value of f over (a,b),
         i.e. to i/(b-a)


machine dependent constants

epmach is the largest relative spacing.
uflow is the smallest positive magnitude.</pre> 
<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l07179">7179</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="accc882b46e46da5e7d2e699dd5a3a18d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqk31 </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resasc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQK31 carries out a 31 point Gauss-Kronrod quadrature rule. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose to compute i = integral of f over (a,b) with error estimate j = integral of abs(f) over (a,b)</p>
<p>Parameters: </p><pre class="fragment">on entry
  f      - real ( kind = 8 )
           function subprogram defining the integrand
           function f(x). the actual name for f needs to be
           declared e x t e r n a l in the calling program.

  a      - real ( kind = 8 )
           lower limit of integration

  b      - real ( kind = 8 )
           upper limit of integration

on return
  result - real ( kind = 8 )
           approximation to the integral i
           result is computed by applying the 31-point
           gauss-kronrod rule (resk), obtained by optimal
           addition of abscissae to the 15-point gauss
           rule (resg).

  abserr - double precison
           estimate of the modulus of the modulus,
           which should not exceed abs(i-result)

  resabs - real ( kind = 8 )
           approximation to the integral j

  resasc - real ( kind = 8 )
           approximation to the integral of abs(f-i/(b-a))
           over (a,b)
</pre><p>Local Parameters:</p>
<pre class="fragment"> the abscissae and weights are given for the interval (-1,1).
 because of symmetry only the positive abscissae and their
 corresponding weights are given.

 xgk    - abscissae of the 31-point kronrod rule
          xgk(2), xgk(4), ...  abscissae of the 15-point
          gauss rule
          xgk(1), xgk(3), ...  abscissae which are optimally
          added to the 15-point gauss rule

 wgk    - weights of the 31-point kronrod rule

 wg     - weights of the 15-point gauss rule
</pre><p>gauss quadrature weights and kronron quadrature abscissae and weights as evaluated with 80 decimal digit arithmetic by l. w. fullerton, bell labs, nov. 1981. </p><pre class="fragment">centr  - mid point of the interval
hlgth  - half-length of the interval
absc   - abscissa
fval*  - function value
resg   - result of the 15-point gauss formula
resk   - result of the 31-point kronrod formula
reskh  - approximation to the mean value of f over (a,b),
         i.e. to i/(b-a)

machine dependent constants

epmach is the largest relative spacing.
uflow is the smallest positive magnitude.</pre> 
<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l07361">7361</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a987f840704b3b872cd642cf1af36eed2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqk41 </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resasc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQK41 carries out a 41 point Gauss-Kronrod quadrature rule. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose to compute i = integral of f over (a,b), with error estimate j = integral of abs(f) over (a,b)</p>
<p>Parameters: </p><pre class="fragment">on entry
  f      - real ( kind = 8 )
           function subprogram defining the integrand
           function f(x). the actual name for f needs to be
           declared e x t e r n a l in the calling program.

  a      - real ( kind = 8 )
           lower limit of integration

  b      - real ( kind = 8 )
           upper limit of integration

on return
  result - real ( kind = 8 )
           approximation to the integral i
           result is computed by applying the 41-point
           gauss-kronrod rule (resk) obtained by optimal
           addition of abscissae to the 20-point gauss
           rule (resg).

  abserr - real ( kind = 8 )
           estimate of the modulus of the absolute error,
           which should not exceed abs(i-result)

  resabs - real ( kind = 8 )
           approximation to the integral j

  resasc - real ( kind = 8 )
           approximation to the integal of abs(f-i/(b-a))
           over (a,b)
</pre><p>Local Parameters:</p>
<pre class="fragment"> the abscissae and weights are given for the interval (-1,1).
 because of symmetry only the positive abscissae and their
 corresponding weights are given.

 xgk    - abscissae of the 41-point gauss-kronrod rule
          xgk(2), xgk(4), ...  abscissae of the 20-point
          gauss rule
          xgk(1), xgk(3), ...  abscissae which are optimally
          added to the 20-point gauss rule

 wgk    - weights of the 41-point gauss-kronrod rule

 wg     - weights of the 20-point gauss rule
</pre><p>gauss quadrature weights and kronron quadrature abscissae and weights as evaluated with 80 decimal digit arithmetic by l. w. fullerton, bell labs, nov. 1981. </p><pre class="fragment">centr  - mid point of the interval
hlgth  - half-length of the interval
absc   - abscissa
fval*  - function value
resg   - result of the 20-point gauss formula
resk   - result of the 41-point kronrod formula
reskh  - approximation to mean value of f over (a,b), i.e.
         to i/(b-a)

machine dependent constants

epmach is the largest relative spacing.
uflow is the smallest positive magnitude.</pre> 
<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l07558">7558</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a4b92c134416731a5f3e54e6ee1b7490f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqk51 </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resasc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQK51 carries out a 51 point Gauss-Kronrod quadrature rule. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose to compute i = integral of f over (a,b) with error estimate j = integral of abs(f) over (a,b)</p>
<p>Parameters: </p><pre class="fragment">on entry
  f      - real ( kind = 8 )
           function defining the integrand
           function f(x). the actual name for f needs to be
           declared e x t e r n a l in the calling program.

  a      - real ( kind = 8 )
           lower limit of integration

  b      - real ( kind = 8 )
           upper limit of integration

on return
  result - real ( kind = 8 )
           approximation to the integral i
           result is computed by applying the 51-point
           kronrod rule (resk) obtained by optimal addition
           of abscissae to the 25-point gauss rule (resg).

  abserr - real ( kind = 8 )
           estimate of the modulus of the absolute error,
           which should not exceed abs(i-result)

  resabs - real ( kind = 8 )
           approximation to the integral j

  resasc - real ( kind = 8 )
           approximation to the integral of abs(f-i/(b-a))
           over (a,b)
</pre><p>Local Parameters:</p>
<p>the abscissae and weights are given for the interval (-1,1). because of symmetry only the positive abscissae and their corresponding weights are given.</p>
<p>xgk - abscissae of the 51-point kronrod rule xgk(2), xgk(4), ... abscissae of the 25-point gauss rule xgk(1), xgk(3), ... abscissae which are optimally added to the 25-point gauss rule</p>
<p>wgk - weights of the 51-point kronrod rule</p>
<p>wg - weights of the 25-point gauss rule</p>
<p>gauss quadrature weights and kronron quadrature abscissae and weights as evaluated with 80 decimal digit arithmetic by l. w. fullerton, bell labs, nov. 1981. </p><pre class="fragment">centr  - mid point of the interval
hlgth  - half-length of the interval
absc   - abscissa
fval*  - function value
resg   - result of the 25-point gauss formula
resk   - result of the 51-point kronrod formula
reskh  - approximation to the mean value of f over (a,b),
         i.e. to i/(b-a)

machine dependent constants

epmach is the largest relative spacing.
uflow is the smallest positive magnitude.</pre> 
<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l07764">7764</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a3f18b6b750d715511cf21b601acd9c63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqk61 </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>resasc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQK61 carries out a 61 point Gauss-Kronrod quadrature rule. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose to compute i = integral of f over (a,b) with error estimate j = integral of abs ( f) over (a,b)</p>
<p>Parameters:</p>
<p>on entry f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the calling program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration</p>
<p>on return result - real ( kind = 8 ) approximation to the integral i result is computed by applying the 61-point kronrod rule (resk) obtained by optimal addition of abscissae to the 30-point gauss rule (resg).</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs ( i-result)</p>
<p>resabs - real ( kind = 8 ) approximation to the integral j</p>
<p>resasc - real ( kind = 8 ) approximation to the integral of abs ( f-i/(b-a))</p>
<p>Local Parameters:</p>
<p>the abscissae and weights are given for the interval (-1,1). because of symmetry only the positive abscissae and their corresponding weights are given.</p>
<p>xgk - abscissae of the 61-point kronrod rule xgk(2), xgk(4) ... abscissae of the 30-point gauss rule xgk(1), xgk(3) ... optimally added abscissae to the 30-point gauss rule</p>
<p>wgk - weights of the 61-point kronrod rule</p>
<p>wg - weigths of the 30-point gauss rule</p>
<p>gauss quadrature weights and kronron quadrature abscissae and weights as evaluated with 80 decimal digit arithmetic by l. w. fullerton, bell labs, nov. 1981.</p>
<p>centr - mid point of the interval hlgth - half-length of the interval dabsc - abscissa fval* - function value resg - result of the 30-point gauss rule resk - result of the 61-point kronrod rule reskh - approximation to the mean value of f over (a,b), i.e. to i/(b-a)</p>
<p>machine dependent constants</p>
<p>epmach is the largest relative spacing. uflow is the smallest positive magnitude. </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l07983">7983</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="aae5d12925721c2511604456c29cf47df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqmomo </td>
          <td>(</td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>alfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(25)&#160;</td>
          <td class="paramname"><em>ri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(25)&#160;</td>
          <td class="paramname"><em>rj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(25)&#160;</td>
          <td class="paramname"><em>rg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(25)&#160;</td>
          <td class="paramname"><em>rh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>integr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQMOMO computes modified Chebyshev moments. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose this routine computes modified chebsyshev moments. the k-th modified chebyshev moment is defined as the integral over (-1,1) of w(x)*t(k,x), where t(k,x) is the chebyshev polynomial of degree k.</p>
<p>Parameters:</p>
<p>alfa - real ( kind = 8 ) parameter in the weight function w(x), alfa.gt.(-1)</p>
<p>beta - real ( kind = 8 ) parameter in the weight function w(x), beta.gt.(-1)</p>
<p>ri - real ( kind = 8 ) vector of dimension 25 ri(k) is the integral over (-1,1) of (1+x)**alfa*t(k-1,x), k = 1, ..., 25.</p>
<p>rj - real ( kind = 8 ) vector of dimension 25 rj(k) is the integral over (-1,1) of (1-x)**beta*t(k-1,x), k = 1, ..., 25.</p>
<p>rg - real ( kind = 8 ) vector of dimension 25 rg(k) is the integral over (-1,1) of (1+x)**alfa*log((1+x)/2)*t(k-1,x), k = 1, ..., 25.</p>
<p>rh - real ( kind = 8 ) vector of dimension 25 rh(k) is the integral over (-1,1) of (1-x)**beta*log((1-x)/2)*t(k-1,x), k = 1, ..., 25.</p>
<p>integr - integer ( kind = 4 ) input parameter indicating the modified moments to be computed integr = 1 compute ri, rj = 2 compute ri, rj, rg = 3 compute ri, rj, rh = 4 compute ri, rj, rg, rh </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l08185">8185</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="aa80dca0345467a0d301c7e0cdb7b0d9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqng </td>
          <td>(</td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsabs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>epsrel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>neval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>ier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQNG estimates an integral, using non-adaptive integration. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose the routine calculates an approximation result to a given definite integral i = integral of f over (a,b), hopefully satisfying following claim for accuracy abs(i-result).le.max(epsabs,epsrel*abs(i)).</p>
<p>Parameters:</p>
<p>f - real ( kind = 8 ) function subprogram defining the integrand function f(x). the actual name for f needs to be declared e x t e r n a l in the driver program.</p>
<p>a - real ( kind = 8 ) lower limit of integration</p>
<p>b - real ( kind = 8 ) upper limit of integration</p>
<p>epsabs - real ( kind = 8 ) absolute accuracy requested epsrel - real ( kind = 8 ) relative accuracy requested if epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28), the routine will end with ier = 6.</p>
<p>on return result - real ( kind = 8 ) approximation to the integral i result is obtained by applying the 21-point gauss-kronrod rule (res21) obtained by optimal addition of abscissae to the 10-point gauss rule (res10), or by applying the 43-point rule (res43) obtained by optimal addition of abscissae to the 21-point gauss-kronrod rule, or by applying the 87-point rule (res87) obtained by optimal addition of abscissae to the 43-point rule.</p>
<p>abserr - real ( kind = 8 ) estimate of the modulus of the absolute error, which should equal or exceed abs(i-result)</p>
<p>neval - integer ( kind = 4 ) number of integrand evaluations</p>
<p>ier - ier = 0 normal and reliable termination of the routine. it is assumed that the requested accuracy has been achieved. ier.gt.0 abnormal termination of the routine. it is assumed that the requested accuracy has not been achieved. error messages ier = 1 the maximum number of steps has been executed. the integral is probably too difficult to be calculated by dqng. = 6 the input is invalid, because epsabs.le.0 and epsrel.lt.max(50*rel.mach.acc.,0.5d-28). result, abserr and neval are set to zero.</p>
<p>Local Parameters:</p>
<p>the data statements contain the abscissae and weights of the integration rules used.</p>
<p>x1 abscissae common to the 10-, 21-, 43- and 87- point rule x2 abscissae common to the 21-, 43- and 87-point rule x3 abscissae common to the 43- and 87-point rule x4 abscissae of the 87-point rule w10 weights of the 10-point formula w21a weights of the 21-point formula for abscissae x1 w21b weights of the 21-point formula for abscissae x2 w43a weights of the 43-point formula for abscissae x1, x3 w43b weights of the 43-point formula for abscissae x3 w87a weights of the 87-point formula for abscissae x1, x2, x3 w87b weights of the 87-point formula for abscissae x4</p>
<p>gauss-kronrod-patterson quadrature coefficients for use in quadpack routine qng. these coefficients were calculated with 101 decimal digit arithmetic by l. w. fullerton, bell labs, nov 1981. </p><pre class="fragment">centr  - mid point of the integration interval
hlgth  - half-length of the integration interval
fcentr - function value at mid point
absc   - abscissa
fval   - function value
savfun - array of function values which have already been
         computed
res10  - 10-point gauss result
res21  - 21-point kronrod result
res43  - 43-point result
res87  - 87-point result
resabs - approximation to the integral of abs(f)
resasc - approximation to the integral of abs(f-i/(b-a))

machine dependent constants

epmach is the largest relative spacing.
uflow is the smallest positive magnitude.</pre> 
<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l08383">8383</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ab944c7552a10c8cbc3fcb711d56a4e73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::dqpsrt </td>
          <td>(</td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>maxerr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>ermax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), dimension(last)&#160;</td>
          <td class="paramname"><em>elist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), dimension(last)&#160;</td>
          <td class="paramname"><em>iord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>nrmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQPSRT maintains the order of a list of local error estimates. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker</p>
<p>***purpose this routine maintains the descending ordering in the list of the local error estimated resulting from the interval subdivision process. at each call two error estimates are inserted using the sequential search method, top-down for the largest error estimate and bottom-up for the smallest error estimate.</p>
<p>Parameters: </p><pre class="fragment">  limit  - integer ( kind = 4 )
           maximum number of error estimates the list
           can contain

  last   - integer ( kind = 4 )
           number of error estimates currently in the list

  maxerr - integer ( kind = 4 )
           maxerr points to the nrmax-th largest error
           estimate currently in the list

  ermax  - real ( kind = 8 )
           nrmax-th largest error estimate
           ermax = elist(maxerr)

  elist  - real ( kind = 8 )
           vector of dimension last containing
           the error estimates

  iord   - integer ( kind = 4 )
           vector of dimension last, the first k elements
           of which contain pointers to the error
           estimates, such that
           elist(iord(1)),...,  elist(iord(k))
           form a decreasing sequence, with
           k = last if last.le.(limit/2+2), and
           k = limit+1-last otherwise

  nrmax  - integer ( kind = 4 )
           maxerr = iord(nrmax)</pre> 
<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l08712">8712</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a786a9bfa65b7c81dcdf6cb63535bfaa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real ( kind = 8 ) function quadpack::dqwgtc </td>
          <td>(</td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>kp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQWGTC defines the weight function used by DQC25C. </p>
<dl class="section author"><dt>Authors</dt><dd>Robert Piessens, Elise de Doncker </dd></dl>
<dl class="section date"><dt>Date</dt><dd>02 January 2017 <br />
 11 September 2015 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>GNU Public License v3 </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Improve the documentation of the function </dd></dl>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l00054">54</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a67cee6fc22a1270385fcf68a692d0924"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real ( kind = 8 ) function quadpack::dqwgtf </td>
          <td>(</td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 )&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 )&#160;</td>
          <td class="paramname"><em>integr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQWGTF defines the weight functions used by DQC25F. </p>
<p>Modified:</p>
<p>11 September 2015</p>
<p>Author:</p>
<p>Robert Piessens, Elise de Doncker </p>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l00118">118</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="a0a2f9faa3dd3d3923d403fb4e248b765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real ( kind = 8 ) function quadpack::dqwgts </td>
          <td>(</td>
          <td class="paramtype">real ( kind = 8 ), intent(in)&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), intent(in)&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), intent(in)&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), intent(in)&#160;</td>
          <td class="paramname"><em>alfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real ( kind = 8 ), intent(in)&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), intent(in)&#160;</td>
          <td class="paramname"><em>integr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DQWGTS defines the weight functions used by DQC25S. </p>
<dl class="section author"><dt>Authors</dt><dd>Robert Piessens, Elise de Doncker </dd></dl>
<dl class="section date"><dt>Date</dt><dd>02 January 2017 <br />
 11 September 2015 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>GNU Public License v3 </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Can we remove the horrible gotos without altering functionality and performances? <br />
 Improve the documentation of the function </dd></dl>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l00078">78</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
<a class="anchor" id="ac1e5b01c1b8779878ebbc064e5f499df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine quadpack::xerror </td>
          <td>(</td>
          <td class="paramtype">character ( len = * ), intent(in)&#160;</td>
          <td class="paramname"><em>xmess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), intent(in)&#160;</td>
          <td class="paramname"><em>nmess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), intent(in)&#160;</td>
          <td class="paramname"><em>nerr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer ( kind = 4 ), intent(in)&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XERROR replaces the SLATEC XERROR routine. </p>
<dl class="section date"><dt>Date</dt><dd>02 January 2017 <br />
 12 September 2015 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>GNU Public License v3 </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Can't this work without nmess? Can we replace this with a better error handler? </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>input error level (?)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nerr</td><td>input number of the error (?)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nmess</td><td>input length of the error message (?)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xmess</td><td>input error message </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="quadpack_8f90_source.html#l00026">26</a> of file <a class="el" href="quadpack_8f90_source.html">quadpack.f90</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 2 2017 16:36:25 for f2kquadpack by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
